---
title: "语法错误记录"
createdAt: "2025-03-26T10:30:00"
updatedAt: "2025-12-11T14:20:00"
---

# 爆int

Q： 在进行计算的时候，没有考虑数据大小导致数值溢出的情形怎么优雅的解决？

A： 进行类型提升；在进行运算的时候，加一个更大的类型，或者与一个更高精度或者更大类型的值相乘，可以完成类型提升







# 空白字符处理

Q：为什么要用getchar（）？

A：因为输入的换行符会停留在缓冲区内，下一次读取输入的时候可能就会读取到换行符，而非正确的字符

```
//input：
123
abc
scanf("%d", &a);   // 输入后按回车，换行符留在缓冲区
scanf("%c", &ch);  // 读取的是换行符（'\n'），ch实际上是一个换行符
```

Q：为什么有的时候不需要getchar读取也不会出问题？

A：因为scanf读取数据的时候，会跳过类型不一样的数据，比如scanf读取%d类型的数据，就会跳过非int型的数据



Q：什么时候必须用getchar？

A： fgets或者getline与scanf混用的时候

# 字符串处理

Q：为什么需要string.c_str()方法？

A：为了C++与C语言兼容，C语言中只有char[]字符串数组和char*字符串指针，并没有string

```
string s = "Hello World!";
printf("%s", s.c_str());    // 输出 "Hello World!"

###########################################################

string line;
sscanf(line.c_str(),"%d:%d",&h,&m);

```

Q：原字符串改变了之后，s.c_str结果会变吗？

A： string类的实现实际上封装着一个char*的指针，而c_str()直接返回该指针的引用，因此string对象的改变会直接影响已经执行过的c_str()返回的指针引用。

```
std::string s = "Chelse";

const char *str = s.c_str();

std::cout << str << std::endl; //输出Chelse

s[1] = 'm';

std::cout << str << std::endl; //输出Cmhelse
```

Q： const char*, char const*, char* const的区别是什么？

A： const char*与char const*是等价的，指的是指向[字符常量](https://so.csdn.net/so/search?q=字符常量&spm=1001.2101.3001.7020)的指针，即指针可以改变指向但其指向的内容不可以改变。 而char* const相反，指的是[常量指针](https://so.csdn.net/so/search?q=常量指针&spm=1001.2101.3001.7020)，即指向不可以改变但指针指向的内容可以改变。

# 初始化问题

Q：memset(dp,100,sizeof dp);初始化结果是什么？

A：memset是逐字节进行初始化的，而int是四字节，因此初始化结果远大于100

```
常用初始化：memset(dp,0,sizeof dp); //准确赋值为0
		  memset(dp,-1,sizeof dp);//准确赋值为-1
	memset(dp,0x3f,sizeof dp);
初始化结果：dp[i] ==0x3f3f3f3f ≈ 1e9
    而INT_MAX=0x7fffffff
```



# 回环访问

Q：如何回环访问一个数组？

A： l = (l-1+n)%n; r = (r+1)%n;

Q：（r+1）%n和（r+1-n）%n结果一样吗？

A： x%n的结果小于n，也就是说，如果x<0，x%n==x。因此r = (r+1)%n;而不要写成r = (r+1-n)%n;



# 如何通过定义宏简化代码？（模板）



```
#include <bits/stdc++.h>
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using i64 = long long;

i64 a; //等价于long long a


int main(){
    IOS;
    
    return 0;
}
    
```



# 如何存图

邻接矩阵

适用于稠密图，边查询效率低

```
inline void add(int u, int v, int w)
{
    mat[u][v] = w;
    mat[v][u] = w;
}
```

邻接表（将邻接矩阵的行转换为链表形式）

适用于边查询较多的情况，但有扩容消耗

```
struct Edge{
	int to,w; //to是下一个节点，w是权值
};
vector <Edge *> v[MAXN];
inline void add(int from, int to, int w)
{
    Edge e = {to, w};
    edges[from].push_back(e);  //向vector的最后添加一条边
}
//对于无向图调用两次add即可
inline void add2(int u, int v, int w)
{
    add(u, v, w);
    add(v, u, w);
}
//遍历2号点所能达到的所有点
for(int i = 0;i<v[2].size();i++){
	cout<<v[2][i].to<<" ";
}
```

链式前向星

存储和处理稀疏图的数据结构

```
struct Edge
{
    int to, w, next; //w代表权值，to代表该边的终点，next代表最新边的上一条边的编号
}edges[MAXM];
int head[MAXN], cnt; // cnt为当前边的编号
inline void add(int from, int to, int w)
{
    edges[++cnt].w = w;    //新增一条编号为cnt+1的边，边权为w
    edges[cnt].to = to;    //该边的终点为to
    edges[cnt].next = head[from];  //把下一条边，设置为当前起点的第一条边
    head[from] = cnt;  //该边成为当前起点新的第一条边
}
//遍历，可以通过head[i]访问i号顶点所能到达的所有点，edges[cnt].next为0的时候，代表抵达终点了
//打印2号顶点能到达的所有点
for (int e = head[2]; e != 0; e = edges[e].next)
    printf("%d ", edges[e].to);
```



# 输入问题

Q：使用scanf的好处和隐患

A： 使用scanf可以做到精准读入，但容易读取到预期之外的内容，比如换行符、空格或者上一次没处理完的输入等等

```
scanf(" %c",&ch); //在前面加一个空格，系统就会跳过所有空白字符，包括换行符、制表符、空格等等，强制等待读取第一个非空白字符
```



# 数组、容器等排序问题

Q：用sort怎么给数组、容器排序？有什么区别？自写cmp函数怎么写？

A：

```
#数组,大小为m
sort(a,a+m,cmp);
#容器：
sort(b.begin(),b.end(),cmp);
#cmp函数：使用&是为了减小开销，使用const是为了使代码更清楚
bool cmp(const DATA_TYPE &a,const DATA_TYPE &b){
	return std::tie(a.first,a.second) < std::tie(b.first,b.second);
}
//tie会生成一个元组，然后按照字典序以此比较元组中的元素
//return std::tie(a.temp1, a.temp2) < std::tie(b.temp1, b.temp2);等价于
//return fly1.temp1<fly2.temp1 || fly1.temp1==fly2.temp1&&fly1.temp2<fly2.temp2;
```

# 处理输入输出问题

## 多组输入（每组固定元素数）

反复输入，直到没有输入

```
while(cin>>a>>b){...}
```

## 多组输入（每组不固定元素）

先读取到字符串中，再把字符串转化为输入流，从中读取数据

">>"在读取输入的时候，会跳过前导空白字符，这有助于我们输入

```c++
#include<sstream>
#include<iostream>
#include<string>
#include<cstring>
using namespace std;
string s;
...
    while(getline(cin,s)){
        stringstream ss(s);
        int num = 0;
        while(ss>>num){...}
    }
...
```

## 非空格间隔的输入

`getline(ss,s,ch)`可以从字符串流`ss`中将字符串读入`s`,这个字符串默认以`\n`结尾，但可以通过参数指定为以`ch`结尾

### 输入

```
a,c,bb
f,dddd
nowcoder
```

### code

```
#include <bits/stdc++.h>
using namespace std;
int main(){
    string s;
    while(getline(cin, s)){
        stringstream ss(s);
        vector<string> v;
        while(getline(ss, s, ',')) v.push_back(s);
        sort(v.begin(), v.end());
        for(int i=0;i<v.size()-1;++i) cout<<v[i]<<',';
        cout<<v.back()<<endl;
    }
    return 0;
}
```

