---
title: "数据结构"
createdAt: "2024-04-18T10:30:00"
updatedAt: "2025-12-11T14:20:00"
---

# 一、顺序表

（逻辑上相邻，物理地址上也相邻）

## 1.顺序表初始化

### 1.1 静态分配

```c
#include<stdio.h>
#define Maxsize 10

struct Sqlist{
	int data[Maxsize];
	int length;
};

void Initlist(struct Sqlist &L){
	//可以设置data的初值，也可以不设置，因为一般合法的访问不会访问到length之外的元素，而length初始化时为0；
	/*
	for(int i = 0;i<Maxsize;i++){
		data[i] = 0;
	} 
	*/ 
	L.length = 0;
}
int main(){
	Sqlist L;
	Initlist(L); //如果初始化没有设置每个数据的初值，而又违规打印了length外的东西，那可能会出现问题，因为data【】的值可能存的是未知的脏数据； 
	
	//“合法”打印
	/*
	for(int i = 0;i<L.length;i++){
		printf("data[%d]:%d\n",i,data[i]);
	}
	*/
	return 0;
}
```

### 1.2 动态分配

```c
#define InitSize 10
struct Seqlist{
	int *data; 
	int Maxsize; //顺序表最大容量
	int length; //当前顺序表长度
};


void Initlist(struct Seqlist &L){
	L.data = (int*)malloc(sizeof(int)*InitSize); //malloc返回的是一个指向首地址的指针，需要强制转换成顺序表里定义的指针的类型； 
	L.length = 0；
	L.Maxsize = InitSize; 
}

//动态增长数组的长度
void IncreaseSize(Seqlist &L,int len){
	int *p = L.data;
	L.data = (int*)malloc(sizeof(int)*(L.Maxsize + len));
	for(int i = 0;i<L.length;i++){
		L.data[i] = p[i];
	}
	L.Maxsize +=len;
	free(p);
} 
int main(){
	Seqlist L;
	Initlist(L);
	//...插入元素
	IncreaseSize(L,5); 
	
	return 0;
}
```

## 2.顺序表特点

1.随机访问，即可以直接访问第i个元素
2.访存密度高
3.拓展容量不方便
4.插入删除不方便

## 3.插入

### 3.1 静态分配的插入

#### 1.0

```c
void InsertList(Sqlist &L,int i,int e){ //在第i位置上插入e，对应的数组下标是i-1； 
	for(int j = L.length;j>=i;j--){
		L.data[j] = L.data[j-1];
	}
	L.length++;
	L.data[i-1] = e;
} //没有进行合法性判断，i可能是不合理的数字，length也可能是最大的了

```

#### 2.0

```C
bool InsertList(Sqlist &L,int i,int e){ //在第i位置上插入e对应的数组下标是i-1；  
	if(i<1 || i>L.length+1) return false;
	if(L.length>=Maxsize) return false; 
	for(int j = L.length;j>=i;j--){
		L.data[j] = L.data[j-1];
	}
	L.length++;
	L.data[i-1] = e;
	return true;
} //可以检查插入合法性并返回一个1或者0；
```

插入操作的时间复杂度 = O(n) ；   n = L.length

### 3.2 静态分配的删除

```C
bool ListDelete(Sqlist &L,int i,int &e){ //删除第i位上的元素，并记录下删除的数据 
	if(i<1 || i>L.length) return false;
	e = L.data[i-1];
	for(int j = i;j<L.length;j++){
		L.data[j-1] = L.data[j];
	}
	L.length--;
	return true;
}


int main(){
	Sqlist L;
	Initlist(L); 
	//....插入元素 
	int e = -1;
	if(ListDelete(L,3,e)); printf("已删除第3个元素，删除的元素值为：%d\n",e);
	else printf("位序不合法,删除失败\n"); 
	return 0;
}
```

删除操作的时间复杂度 = O(n);

## 4.查找

### 4.1按位查找

```C
ElemType GetElem(seqList L, int i){
	return L.data[i-1]; //因为强制转换了malloc返回的指针的数据类型，所以返回的地址长度刚好是一个数据的大小，如果没有强制转换malloc返回的数据类型，那查找操作返回的数据就会出现问题；
}
```

### 4.2按值查找

```c
int LocateElem(SeqList L,int e){
	for(int i = 0;i<L.length;i++);
		if(L.data[i] == e) return i+1;
	return 0;
}
```

# 二、单链表

（用链式存储的方式实现了线性结构）

## 1.初始化

### 1.1 不带头结点

```c
typedef struct LNode{ //定义单链表结构类型 
	ElemType data; //每个节点存放一个数据元素 
	struct LNode *next; //指针指向下一个节点 
}LNode,*LinkList; //typedef是重命名数据结构的名字，两个名字本质上是一样的，只是用于区分结点和指针； 

bool InitList(LinkList &L){
	L = NULL; //此时L为空表，暂时无任何结点 
	return true;
}
```



### 1.2 带头结点

```C
typedef struct LNode{ //定义单链表结构类型 
	ElemType data; //每个节点存放一个数据元素 
	struct LNode *next; //指针指向下一个节点 
}LNode,*LinkList; //typedef是重命名数据结构的名字，两个名字本质上是一样的，只是用于区分结点和指针； 
//带头结点的链表的初始化
bool InitList(LinkList &L){
	L = (LNode*)malloc(sizeof(LNode));  //分配头结点 
	if (L == NULL) return false; //内存不足，分配失败 
	L->next = NULL; 
	return true;
} 
```

### 1.3 判断是否为空表

```c
bool Empty(LinkList L){
	return (L == NULL);
} 
```

## 2.插入

### 2.1按位序插入

#### 2.1.1 带头结点

```c
bool ListInsert(LinkList &L,int i,ElemType e){
	if(i<1) return false; //非法值 
	LNode *p; //用来指向当前扫描到的结点 
	int j = 0; //当前p指向的是哪个结点 
	p = L; //L指向头结点，头结点不存数据 
	while(p !=NULL && j<i-1){ //寻找第i-1个结点 
		p = p->next;
		j++;
	}
	if(p == NULL) return false; //i值不合法，因为i-1个结点为空结点 
	LNode *s = (LNode *)malloc(sizeof(LNode));
	s->data = e;
	s->next = p->next
	p->next = s;
	return true;
} 
```

#### 2.1.2 不带头结点

```C
bool ListInsert(LinkList &L,int i,ElemType e){
	if(i<1) return false; //非法值 
	if(i==1){
		LNode *s = (LNode *)malloc(sizeof(LNode));
		s->data = e;
		s->next = L;
		L = s; //头指针指向新结点
		return true;
	} 
	LNode *p; //用来指向当前扫描到的结点 
	int j = 1; //当前p指向的是哪个结点 
	p = L; 
	while(p !=NULL && j<i-1){ //寻找第i-1个结点 
		p = p->next;
		j++;
	}
	if(p == NULL) return false; //i值不合法，因为i-1个结点为空结点 
	LNode *s = (LNode *)malloc(sizeof(LNode));
	S->data = e;
	s->next = p->next
	p->next = s;
	return true;
} 
```

### 2.2 指定头结点插入

#### 2.2.1 前插

```C
bool InsertNext (LNode *p,ElemType e){
	if(p== NULL) return false;
	LNode *s = (LNode*)malloc(sizeof(LNode));
	if(s == NULL) return false; //分配内存失败 
	s->data = e;
	s->next = p->next;
	p->next = s;
	return true;	
}
```

#### 2.2.2 后插

```C
bool InsertPriorNode(LNode *p,ElemType e){ //偷天换日的前插操作，实际上只是在p后面后插了一个存储空间，然后把p结点内容赋值到这个空间，再把要插入的东西放到p结点中，实现前插，时间复杂度大大降低 
	if(p==NULL) return false;
	LNode *s = (LNode*)malloc(sizeof(LNode));
	s->data = p->data;
	s->next = p->next;
	p->next = s;
	p->data = e;
	return true;
}
```

## 3.删除

### 3.1 按位序删除

```C
bool ListDelete(LinkList &L,int i,ElemType &e){
	if(i<1) return false; //非法值 
	LNode *p; //用来指向当前扫描到的结点 
	int j = 0; //当前p指向的是哪个结点 
	p = L; //L指向头结点，头结点不存数据 
	while(p !=NULL && j<i-1){ //寻找第i-1个结点 
		p = p->next;
		j++;
	}
	if(p == NULL) return false; //i值不合法，因为i-1个结点为空结点 
	if(p->next==NULL) return false; //第i-1个结点之后没有其他结点了 
	LNode *q = p->next; //令q指向被删除结点 
	e = q->data; //用e记录删除的值 Q：q不是只是等于p的next吗，在上一句中，那按道理他的data不应该是空的吗，上一句其实是赋值了整个结点？ A:这是C语言中的结构体指针访问成员的方法
	p->next = q->next;
	free(q);
	return true; 
	 
}
```

### 3.2 指定结点删除

```c
bool DeleteNode(LNode *p){
	if(p == NULL) return false;
	LNode *q = p->next;
	p->data = p->next->data;
	p->next = q->next;
	free(q);
	return true;
} 
```

我觉得更简洁的写法：（不知道对不对）

```c
bool DeleteNode(LNode *p){
	if(p == NULL) return false;
	LNode *q = p->next;
	p = q;
	free(q);
	return true;
} 
```

## 4.查找（带头结点）

### 4.1 按位查找

```c
LNode *GetElem(LinkList L,int i){
	if(i<0) return NULL;
	LNode *p;
	int j = 0;
	while(p!= NULL && j<i){
		p = p->next;
		j++;
	}
	return p;
}
```

### 4.2 按值查找

```c
LNode *LocateElem(LinkList L,ElemType e){
	LNode *p = L->next;
	while(p !=NULL && p->data !=e) p = p->next;
	return p;
}
```

## 5.求表长

```c
int Length(LinkList L){
	int len = 0;
	LNode *p = L;
	while(p->next !=NULL){
		p = p->next;
		len++;
	}
	return len;
}
```

## 6.单链表的建立（带头结点）

核心就是初始化操作，指定结点的后插操作

## 6.1 尾插法

```c
LinkList List_TailInsert(LinkList &L){
	int x;
	L = (LinkList)malloc(sizeof(LNode));
	LNode *s,*r = L; //r为表尾指针 
	scanf("%d",&x); //输入要插入的数据 
	while(x!=9999){
		s = (LNode*)malloc(sizeof(LNode));
		s->data = x;
		r->next = s;
		r = s;  //r指向新的表尾结点 
		scanf("%d",&x);
	}
	r->next = NULL; //尾结点指针置空 
	return L;
}
```

## 6.2 头插法

链表的逆置

```C
LinkList List_HeadInsert(LinkList &L){
	int x;
	L = (LinkList)malloc(sizeof(LNode));
	LNode *s; //r为表尾指针 
	scanf("%d",&x); //输入要插入的数据 
	while(x!=9999){
		s = (LNode*)malloc(sizeof(LNode));
		s->data = x;
		s->next = L->next;
		L->next = s;  //r指向新的表尾结点 
		scanf("%d",&x);
	}
	return L;
}
```

# 三、双链表

## 1.初始化

```C
typedef struct DNode{
	ElemType data;
	struct DNode *prior,*next;
}DNode,*DLinkList;

bool InitDList(DlinkList &L){
	L = (DNode*)malloc(sizeof(DNode));
	if(L==NULL) return false;
	L->prior = NULL;
	L->next = NULL;
	return true;
} 
```

## 2.插入（后插）

因为有prior的存在，所以前插就可以变为结点的prior的后插操作

```c
bool InsertNextDNode(DNode *p,DNode *s){
	if(p==NULL || s==NULL) return false;
	s->next = p->next;
	if(p->next!=NULL)//如果p结点有后续结点
		p->next->prior = s;
	s->prior=p;
	p->next=s;
	return true; 
}
```

## 3.判断是否为空表

```c
bool Empty(DLinkList L){
	if(L->next==NULL) return true;
	else return false;
}
```

## 4.删除

```c
bool DeleteNextDNode(DNode *p){
	if(p==NULL) return false;
	DNode *q = p->next;
	if(q==NULL) return false;
	p->next = q->next;
	if(q->next!=NULL) q->next->prior = p;
	free(q);
	return true;
}
```

## 5.双链表的遍历

### 5.1 后向遍历

```c
while(p!=NULL){
    //对结点的操作，如打印
    p=p->next;
}
```

### 5.2 前向遍历

```C
while(p!=NULL){
    //对结点的操作，如打印
    p=p->prior;
}
```

#### （跳过头结点）

```
while(p->prior!=NULL){
    //对结点的操作，如打印
    p=p->prior;
}
```

# 四、循环链表



单链表循环链表、双链表循环链表

初始化、判断是否为空表

判断结点p是否是尾结点

在表头、表尾、表中插入/删除一个结点

# 五、静态链表

## 定义（用数组实现链表）

```c
#define Maxsize 10
typedef struct{ //静态链表结构类型的定义 
	int data; //存储数据元素 
	int next; //下一个元素的数组下标 
} SLinkList[MaxSize];
```

优点：增删操作不需要大量移动元素

缺点：不能随机存取，容量固定不变

使用场景：①不支持指针的低级语言
					 ②数据元素数量固定不变的场景（操作系统的文件分配表FAT）

# 六、小结

## 1.逻辑结构

都属于线性表，都是线性结构

## 2.存储结构

顺序表：优：随机存取，存储密度高 	缺：改变容量不方便，大片连续空间分配不方便

链表：优：空间分配方便，改变容量方便 	缺：不可随机存取，存储密度低

## 3.基本操作

（创销、增删改查）

# 七、顺序存储的栈

栈是只允许在一端进行插入或删除操作的线性表（n个不同的元素进栈，出栈元素排列个数为（1/n+1）C（2n）^n）

```c
#define Maxsize 10
typedef struct{
	ElemType data[MaxSize]; //静态数组存放栈中元素 
	int top; //栈顶指针 
}SqStack; 

void InitStack(SqStack &S){
	S.top = -1;
} 

```

## 1.入栈

```c
bool Push(SqStack &S,ElemType x){
	if(S.top == MaxSize-1) return false; //栈满 
	S.top = S.top + 1; //指针先加一
	S.data[S.top] = x; //新元素入栈
    //或者写成S.data[++S.top] = x;
	return true;
}
```

## 2. 出栈

```C
bool Pop(SqStack &S,ElemType &x){
	if(S.top == -1) return false;
	x = S.data[S.top];
	S.top = S.top - 1;
	return true; 
} //下移了top指针，逻辑上删除了栈顶元素，实际上内存中还有该元素
```

## 3.读栈元素

```c
bool GetTop(SqStack S,ElemType &x){
	if(S.top == -1) return false;
	x = S.data[S.top];
	return true;
}
```

## 4.共享栈

```c
typedef struct{
	int data;
	int top0;
	int top1;
}ShStack;

void InitStack(ShStack &S){
	S.top0 = -1;
	S.top1 = MaxSize;
}
```

# 八、链式存储的栈

## 1.初始化

```C
typedef struct{
	ElemType data;
	struct Linknode *next;
} *LiStack;
```

# 九、顺序结构实现队列

一端进行添加，一端进行删除

1. ## 初始化

```c
typedef struct{
	ElemType data[MaxSize];
	int front,rear;
}SqQueue; 

void InitQueue(SqQueue &Q){
	Q.rear = Q.front = 0;
}
```

2. ## 入队

```c
bool EnQueue(SqQueue &Q,ElemType x){
	if((Q.rear+1)%MaxSize == Q.front) return false;
	Q.data[Q.rear] = x;
	Q.rear = (Q.rear + 1)%MaxSize; //用模运算将存储空间从逻辑上变成环状 
	return true;
}
```

3. ## 出队

```c
bool DeQueue(SqQueue &Q,ElemType &x){
	if(Q.rear == Q.front) return false;
	x = Q.data[Q.front];
	Q.front = (Q.front+1)%MaxSize;
	return true;
} 
```

4. ## 获得头元素

```c
bool GetHead(SqQueue &Q,ElemType &x){
	if(Q.rear == Q.front) return false;
	x = Q.data[Q.front];
	return true;
}
```

# 十、链式结构实现队列

## 1. 初始化（带头结点）

```C
typedef struct LinkNode{
	ElemTyepe data;
	struct LinkNode *next;	
}LinkNode;

typedef struct{
	LinkNode *front,*rear;
}LinkQueue;

void InitQueue(LinkQueue &Q){
	//初始时，front和rear都指向头结点
	Q.front = Q.rear =(LinkNode)malloc(sizeof(LinkNode));
	Q.front->next = NULL;
}
```

## 2. 出队

### （不带头结点）

```c
bool DeQueue(LinkQueue &Q,ElemType &x){
	if(Q.front == NULL) return false;
	LinkNode *p = Q.front;
	x = p->data;
	Q.front = p->next;
	if(Q.rear == p){
		Q.front = NULL;
		Q.rear = NULL;
	}
	free(p);
	return true;
}
```

### （带头结点）

```C
bool DeQueue(LinkQueue &Q,ElemType &x){
	if(Q.front == Q.rear) return false;
	LinkNode *p = Q.front->next;
	x = p->data;
	Q.front->next = p->next;
	if(Q.rear == p){
		Q.rear = Q.front;
	}
	free(p);
	return true;
}
```

## 3. 入队

### （带头结点）

```c
void EnQueue(LinkQueue &Q,ElemType x){
	LinkNode *s = (LinkNode *)malloc(sizeof(LinkNode));
	s->data = x;
	s->next = NULL;
	Q.rear->next = s;
	Q.rear = s;
}
```

### （不带头结点）

```C
void EnQueue(LinkQueue &Q,ElemType x){
	LinkNode *s = (LinkNode *)malloc(sizeof(LinkNode));
	s->data = x;
	s->next = NULL;
	if(Q.front == NULL){
		Q.front = s;
		Q.rear = s;
	}
	else{
		Q.rear->next = s;
		Q.rear = s;
	}
}
```

# 十一、栈的应用

## 1.括号匹配

```C
bool bracketCheck(char str[], int length){
	SqStack S;
	InitStack[S];
	for(int i =0;i<length; i++){
		if(str[i] == '(' || str[i] =='{' ||str[i] =='[' ){
			Push(S,str[i]);
		}else{
			if(StackEmpty(S)) return false; //扫描到右括号且当前栈空 
			char topElem;
			Pop(S,topElem;) //栈顶元素出栈
			if(str[i] == ')' && topElem !='(') return false;
			if(str[i] == ']' && topElem !='[') return false;
			if(str[i] == '}' && topElem !='{') return false; 
		}
	}
	return StackEmpty(S);
}
```

## 2.表达式求值

中缀表达式：运算符在两个操作数中间

后缀表达式：运算符在两个操作数后面

前缀表达式：运算符在两个操作数前面



用栈实现中缀表达式转后缀表达式：
① 遇到操作数直接加入后缀表达式
②遇到界限符。遇到“（”直接入栈；遇到“）”则依次弹出栈内运算符并加入后缀表达式，直到弹出“（”为止，注意“（”不加入后缀表达式
③ 遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“（”或栈空则停止，之后再把当前运算符入栈

## 3.递归

# 十二、队列的应用

## 1.树的层次遍历

```C

```



## 2.图的广度优先遍历



# 十三、串

## 1.串的定义

```C
typedef struct{
	char ch[MAXLEN];
	int length;
}SString;

typedef struct{
	char *ch;
	int length;
}HString;

typedef struct StringNode{
	char ch;
	struct StringNode *next;
}StringNode,*String;

typedef struct StringNode{
	char ch[4];
	struct StringNode *next;
}StringNode, *String;
```

## 2.求子串

```c
typedef struct{
	char ch[MAXLEN];
	int length;
}SString;
bool SubString(SString &Sub,SString S,int pos,int len){ //返回S中从pos起的长度为len的字符 
	if(pos+len-1 > S.length) return false;
	for(int i = pos;i<pos+len;i++) Sub.ch[i-pos+1] = S.ch[i];
	Sub.length = len;
	return true;
}
```

## 3.比较操作

```c
int StrCompare(SString S,SString T){
	for(int i =1;i<=S.length && i<=T.length;i++){
		if(S.ch[i]!=T.ch[i]) return S.ch[i]-T.ch[i];
	}
	return S.length-T.length; //遍历完之后若都相等，则比大小
} 
=0则一样大，>1则前者更大，反之后者更大
```

## 4.定位操作

```C
int Index(SString S,SString T){
	int i = 1,n = StrLength(S),m = StrLength(T);
	SString sub;
	while(i<=n-m+1){
		SubString(sub,S,i,m);
		if(StrCompare(sub,T) != 0) ++i;
		else return i; //返回子串在主串中的位置 
	}
	return 0; 
}
```

## 5.朴素模式匹配

```C
int Index(SString S,SString T){
	int i = 1,j=1;
	while(i<=S.length && j<=T.length){
		if(S.ch[i]==T.ch[j]){
			++i; ++j;
		}
		else{
			i = i-j+2;
			j = 1;
		}
	}
	if(j>T.length) return i-T.length;
	else return 0;
}
```

时间复杂度O（mn）

## 6.KMP算法

```C
int Index_KMP(SString S,SString T,int next[]){
	int i =1,j=1;
	while(i<=S.length && j<=T.length){
		if(j==0||S.ch[i]==T.ch[j]){
			++il
			++j;
		}
		else j=next[j]; //模式串向右移动 
	}
	if(j>T.length) return i-T.length; //匹配成功 
	else return 0;
}

```

O（m+n）

## 7.求next数组

前缀：包含模式串第一个字母且不包含最后一个字符的子串。
后缀：包含模式串最后一个字母且不包含第一个字符的子串

next数组的值为前后缀最大相等的字符串的个数+1；

```c
//求模式串T的next数组
void get_next(SString T,int next[]){
	int i = 1,j = 0;
	next[1] = 0;
	while(i<T.length){
		if(j==0||T.ch[i]==T.ch[j]){
			++i;
			++j; //若pi = pj，则next[j+1] = next[j]+1 
			next[i] = j;
		}
		else j = next[j]; //否则令j = next[j],循环继续 
	}
} 
```

稍微优化一点的nextval数组

```c
nextval[1] = 0;
for(int j =2;j<=T.length;j++){
	if(T.ch[next[j]]==T.ch[j]]) nextval[j] = nextval[next[j]];
	else nextval[j] = next[j];
}

```

# 十四、树与二叉树

属性：结点的层次（深度）-- 从上往下数
结点的高度--从下往上数
树的高度（深度） -- 总共多少层
结点的度 == 有几个分支
树的度-- 各结点的度的最大值

## 1.二叉树（有序树）

满二叉树
完全二叉树
二叉排序树：左子树上所有的结点关键字均小于根结点关键字
						  右子树上所有的结点的关键字均大于根结点的关键字
平衡二叉树：任一结点的左子树和右子树的深度之差不超过1.

### 1.1 存储结构

### 1.1.1 顺序存储

顺序存储中，要把二叉树的结点编号与完全二叉树对应起来。因此顺序存储结构只适合存储完全二叉树

```c
struct TreeNode{
	ElemType value;
	bool isEmpty;
}; 

for(int i=0;i<MaxSize;i++){
	t[i].isEmpty = true;
}

```

### 1.1.2 链式存储



```C
typedef struct BiTNode{
	ElemType data; //数据域 
	struct BiTNode *lchild,*rchild; //左右孩子指针 
}BiTNode,*BiTree; 
```

## 2. 遍历

先序遍历：根左右

```C
void PreOrder(BiTree T){
	if(T!=NULL){ 
    visit(T);
	PreOrder(T->lchild);
	PreOrder(T->rchild);
    }   
}
```

中序遍历：左根右

```C
void InOrder(BiTree T){
	if(T!=NULL){ 
    visit(T->lchild);
	InOrder(T);
	InOrder(T->rchild);
    }
}
```

后序遍历：左右根

```C
void PoseOrder(BiTree T){
	if(T!=NULL){
    visit(T->lchild);
	PoseOrder(T->rchild);
	PoseOrder(T);
    }
}
```

（对算术表达式的分析树进行先序、中序、后序遍历，相应得到前缀、中缀、后缀表达式）

层次遍历

```C
void LevelOrder(BiTree T){
	LinkQueue Q;
	InitQueue(Q);
	BiTree p;
	EnQueue(Q,T); //将根结点入队 
	while(!IsEmpty(Q)){
		DeQueue(Q,p); //队头结点出队 
		visit(p);
		if(p->lchild!=NULL) EnQueue(Q,p->lchild); //左孩子入队 
		if(p->rchild!=NULL) EnQueue(Q,p->rchild); //右孩子入队 
	}	
}
```

## 3.线索二叉树

```c
typedef struct ThreadNode{
	ElemType data;
	struct ThreadNode *lchild,*rchild;
	int ltag,rtag; //左、右线索标志 
}ThreadNode,*ThreadTree;
```

### 3.1中序遍历二叉树线索化

```C

```

### 3.2 后序遍历二叉树线索化



### 3.3 先序遍历二叉树线索化







# 十五、树

## 1.双亲表示法（顺序存储）

查找指定双亲方便；查指定孩子只能遍历；删除数据之后产生的空数据导致遍历变慢；

```c
typedef struct{
	PTNode nodes[MAX_TREE_SIZE];
	int n;
}PTree;
```

## 2.孩子表示法

```c
struct CTNode{
	int child; //孩子结点在数组中的位置 
	struct CTNode *next; //下一个孩子 
};

typedef struct{
	ElemType data;
	struct CTNode *firstChild; //第一个孩子 
}CTBox;

typedef struct{
	CTBox nodes[MAX_TREE_SIZE];
	int n,r; //结点数和根的位置 
}CTree; 
```

## 3.兄弟孩子表示法

```C
typedef struct CSNode{
	ElemType data; //数据域 
	struct CSNode *firstchild,*nextsibling; //第一个孩子和右兄弟指针 
}CSNode,*CSTree;
```

## 4.树的遍历

### 4.1 深度优先遍历

#### 4.1.1 先根遍历

若树非空，先访问根结点，再依次对每棵子树进行先根遍历。

#### 4.1.2 后根遍历

若树非空，先依次对每根子树进行后根遍历，最后再访问根结点

### 4.2 广度优先遍历

#### 4.2.1 层次遍历

1.若树非空，则根节点入队
2.若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队
3.重复2直到队列为空

## 5.森林

（是m棵互不相交的树的集合，每棵树去掉根节点后，其子树又组成森林）

先序遍历森林和中序遍历森林都可以转换为用对应方法遍历组成森林的树

### 5.1 先序遍历森林

若森林为非空，则按如下规则进行遍历:
访问森林中第一棵树的根结点。
先序遍历第一棵树中根结点的子树森林。
先序趟历除去第一棵树之后剩余的树构成的森林

### 5.2 中序遍历森林

若森林为非空，则按如下规则进行遍历:
中序遍历森林中第一棵树的根结点的子树森林
访问第一棵树的根结点。
中序遍历除去第一棵树之后剩余的树构成的森林

### 5.3 不同结构遍历的转换

树
无根遍历
后根遍历
森林
先序遍历
中序遍历
二叉树
先序遍历
中序遍历

## 6 哈夫曼树

在含有n个带权叶结点的二叉树中，其中带权路径长度(WPL) 最小的二叉树称为哈夫曼树，也称最优二叉树

结点的权:有某种现实含义的数值(如:表示结点的重要性等 )
结点的带权路径长度:从树的根到该结点的路径长度(经过的边数)与该结点
树的带权路径长度：树中所有叶结点的带权路径长度之和





# 十六、 并查集（P55 暂略）





# 十七、图

有向图与无向图

简单图与多重图

## 1.无向图

### 1.1邻接矩阵图

#### 1.1.1代码实现

```c
 
/*邻接矩阵的结构表示*/
 
#include <iostream>
using namespace std;
 
#define MaxInt 32767       /*表示∞（无限）*/
#define MaxVNum 100        /*表示图中最多可以包含的顶点数*/
 
typedef char Vextype;      /*将顶点的数据类型设为字符型，如果你喜欢也可以把它设成更复杂的结构体*/
typedef int Arctype;       /*将边的权值设为整型*/
 
typedef struct
{
    Vextype vexs[MaxVNum];              /*用来保存顶点信息的一维数组*/
    Arctype arcs[MaxVNum][MaxVNum];     /*邻接矩阵*/
    int vexnum, arenum;                 /*记录图的顶点数和边数*/
} AMGraph;                              /*将结构体命名为AMGraph*/

```



### 2.1邻接表

#### 2.1.1代码实现

```c
/*邻接表的结构表示*/
 
typedef struct ArcNode         /*边结点*/
{
    int anothervex;            /*另一个顶点的编号*/
    ArcNode *nextarcnode;      /*指向下一边结点的指针*/
    int weight;                /*权*/
};
 
typedef struct VexNode         /*头结点*/
{
    VexType data;              /*起始顶点的信息*/
    ArcNode *nextarcnode;      /*指向下一边结点的指针*/
};
 
typedef struct ALGraph         /*邻接表图*/
{
    VexNode ALs[MaxInt];       /*头结点数组*/
    int vexnum, arcnum;        /*顶点数、边数*/
};

```

## 2.有向图

### 2.1 定义

有向图是一副具有方向性的图，是有一组顶点和一组有方向的边组成的，每条方向的边都连接着一对有序的顶点。
*全部由无向边构成图称为无向图*



关于度：出度：有某个顶点指出的边的个数称为该顶点的出度。
入度：指向某个顶点的边的个数称为该顶点的入度。
度：入度+出度，称为该顶点的度。
*注意：自环（起点和终点为同一顶点），此时出度算一度，入度也算一度。*

### 邻接表代码实现

```C
#include <stdio.h>  
#include <stdlib.h>  
#include <stdbool.h>  
  
#define MAXN 100 // 假设最多有100个顶点  
  
// 邻接表节点  
typedef struct EdgeNode {  
    int adjvex;  
    struct EdgeNode *next;  
} EdgeNode, *Edge;  
  
// 邻接表  
typedef struct VertexNode {  
    int vertex;  
    Edge first;  
} VertexNode, Vertex[MAXN];  
  
typedef struct {  
    Vertex adjList[MAXN];  
    int n, e; // 顶点数和边数  
} Graph;  
```





# 堆

## 1.定义：

堆一般指的是二叉堆，顾名思义，二叉堆是完全二叉树或者近似完全二叉树

## 2.性质

1.是一颗完全二叉树

2.通常用数组表示

3.每个节点的值都大于等于其子节点的值称为最小堆，反之称为最大堆

## 3.堆排序算法

```c
#include<iostream>
#include<algorithm>
using namespace std;
 
void heap(int arr[],int i,int n){
	int min=i;
	int left=2*i+1;
	int right=2*i+2;
	if(arr[min]>arr[left]&&left<n)min=left;
	if(arr[min]>arr[right]&&right<n)min=right;
	if(min!=i){
		swap(arr[min],arr[i]);
		heap(arr,min,n);
	}
}
int main()
{
	int n;
	cin>>n;
	int arr[n-1];
	for(int i=0;i<n;i++)cin>>arr[i];
	for(int i=n/2-1;i>=0;i--)heap(arr,i,n);//建堆也是排序第一步 
//	for(int i=n-1;i>=0;i--){
//		swap(arr[0],arr[i]);
//		heap(arr,0,i);
//	} 
	for(int i=0;i<n;i++)cout<<arr[i]<<' ';
	return 0;
 
 } 
```

## 4.堆的建立

```c
strcut MaxHeap
{
	Etype *heap; //数据元素存放的空间，下标从1开始存数数据，下标为0的作为工作空间，存储临时数据
	int HeapSize;//数据元素的个数
	int MaxSize; //存放数据元素空间的大小
};
MaxHeap H;
 
void MaxHeapInit (MaxHeap &H)
{
	for(int i = H.HeapSize/2; i>=1; i--)
	{
		H.heap[0] = H.heap[i];
		int son = i*2;
		while(son <= H.HeapSize)
		{
			if(son < H.HeapSize && H.heap[son] < H.heap[son+1])
				son++;
			if(H.heap[0] >= H.heap[son])
				break;
			else
			{
				H.heap[son/2] = H.heap[son];
				son *= 2;
			}
		}
		H.heap[son/2] = H.heap[0];
	}
}
```















# C语言基础

## 符号优先级

![image-20240111155615761](C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20240111155615761.png)

![image-20240111155637510](C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20240111155637510.png)

## 结构体指针

***结构体指针的访问变量方法***
1）p->结构体成员；
2）(*p).结构体成员；









































































































































































































































































































































































































































































































































































































































































































































































































































































































