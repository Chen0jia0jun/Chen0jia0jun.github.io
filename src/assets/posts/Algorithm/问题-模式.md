---
title: "刷题记录"
createdAt: "2025-03-02T10:30:00"
updatedAt: "2025-12-11T14:20:00"
---

# 基础模板

```c
#include<bits/stdc++.h>
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

using ll = long long;

int main(){
    IOS;
    
    return 0;
}
```



# 粗心小天才

算法正确但没有全部样例AC的情况

①数据类型开太小

```
字符串长度为2e5，求满足某条件的子串数量
答案数可能大于1e9，所以应该开long long
```

②判定条件太狭隘

```
for(int i = 0;i<s.size();i++){
    	if(s[i]==a) head.push_back(i);
    	else if(s[i]==b) low.push_back(i);
	}
//这里应该写成if，而不是else if，因为题目并没有说a和b不能相等，即头尾可能相等
```

③忽略了特殊情况

```
if(head.size()==0||low.size()==0){
        cout<<0<<endl;
        return 0;
    }
这里可能没有捕获到字符，那么答案就为0，如果没有加这一个判定，那后面程序可能出错
```

④在写bfs或者dfs时，判断是否超出边界的变量名字总写错

⑤做“红与黑”时，忘记长宽不是一个数字了，结果判断越界的时候写错了；并且这题不需要回溯现场，是flood fill的，回溯现场写出来也错了；题目也可能违反规则，要进行判断，不然过不了所有样例









# 地牢大师（这题真坐牢）

## 模式：BFS

## 关键点

-常规题，搞错维度改了很久的代码····

-不知道为什么，dis和mp数组合为v数组来用会错，但分开来就又对了···懒得探究了···

## 核心代码

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<pair<int,int>,int> PII;
const int N = 110;
int l,r,c;
char f[N][N][N];
int v[N][N][N];
int mp[N][N][N];
queue<PII> q;
int bfs(int sx,int sy,int sz){
    mp[sz][sx][sy] = 1;
    pair<int,int> start = {sx,sy};
    PII node = {start,sz};
    v[sx][sy][sz] = 0;
    q.push(node);
    int dx[] = {0,0,-1,1,0,0};
    int dy[] = {-1,1,0,0,0,0};
    int dz[] = {0,0,0,0,1,-1};
    while(!q.empty()){
        auto t = q.front();
        q.pop();
        pair<int,int> ft = t.first;
        int x,y,z;
        x = ft.first;
        y = ft.second;
        z = t.second;
        for(int i = 0;i<6;i++){
            int nx,ny,nz;
            nx = x + dx[i];
            ny = y + dy[i];
            nz = z + dz[i];
            //判断越界
            if(nx<1 || ny<1 || nz<1 || nx>r || ny>c || nz>l)
                continue;
            if(f[nz][nx][ny]=='#')
                continue;
            if(mp[nz][nx][ny]!=0)
                continue;
            mp[nz][nx][ny] = 1;
            v[nz][nx][ny] = v[z][x][y] + 1;
            // printf("v[%d][%d][%d]:%d\n",nz,nx,ny,v[nz][nx][ny]);
            if(f[nz][nx][ny]=='E'){
                // printf("v[%d][%d][%d]:%d\n",z,x,y,v[z][x][y]);
                return v[nz][nx][ny];
            }
            q.push({{nx,ny},nz});
        }
    }
    return 0;
}
```



# 全球变暖

## 模式：BFS

## 关键点

-搜索惯用的细节：从图外开始搜索，防止卡图

-本题搜索到了岛之后，假设这个岛会被淹没，随后把与它相连的岛全部标记，标记过程中进行判断是否会被淹没

-但我的写法有一个缺陷，就是```dao()```在搜索的时候会进行标记，若输入满足某种情况，则程序仍然会卡图。。因此我的代码有严重缺陷。

-改进方法就是在main函数中采用双层循环，遍历所有的岛屿，若为‘#’则进行```bfs```搜索,其他部分思路不变。

## 核心代码

```c
/*
以下代码虽然通过了题目，但存在问题。
以下样例无法通过
9
.........
.#######.
.##...##.
.##.#.##.
.##...##.
.#######.
.........
.........
.........
*/
...
const int N = 1e3 + 10;
char f[N][N];
int v[N][N];
int num = 0;
int n;
void dao(PII start){
    queue <PII> q;
    q.push(start);
    int dx[] = {0,0,-1,1};
    int dy[] = {-1,1,0,0};
    bool flag = true;
    while(!q.empty()){
        int nx,ny;
        auto t = q.front();
        q.pop();
        for(int i = 0;i<4;i++){
            nx = t.first + dx[i];
            ny = t.second + dy[i];
            //越界
            if(nx<0 || ny<0 || nx>n || ny>n) continue;
            if(v[nx][ny]) continue;
            if(f[nx][ny]=='.') continue;
            v[nx][ny] = 1;
            PII next = {nx,ny};
            q.push(next);
            //是的话结束循环，不会被淹没
            if(f[t.first][t.second-1]=='#'&&
            f[t.first][t.second+1]=='#'&&
            f[t.first-1][t.second]=='#'&&
            f[t.first+1][t.second]=='#' && flag
            ){
                flag = false;
                num--;
            }}}}
void bfs(PII start){
    queue <PII> q;
    q.push(start);
    int dx[] = {0,0,-1,1};
    int dy[] = {-1,1,0,0};
    while(!q.empty()){
        int nx,ny;
        auto t = q.front();
        q.pop();
        for(int i = 0;i<4;i++){
            nx = t.first + dx[i];
            ny = t.second + dy[i];
            //越界
            if(nx<0 || ny<0 || nx>n || ny>n) continue;
            if(v[nx][ny]) continue;
            v[nx][ny] = 1;
            PII next = {nx,ny};
            if(f[nx][ny] == '#'){
                num++;
                dao(next);
            }
            q.push(next);
        }
    }
}
int main(){
    ...
    PII start = {0,0};
    bfs(start);
    cout<<num<<endl;
    return 0;
}
```

```c
/*懒得重写代码了，找了别人的代码，思路与我的一致，只不过它BFS，但其实是一样的*/

#include<bits/stdc++.h>
using namespace std;

int n;
char a[1010][1010]; //地图
int vis[1010][1010]={0};  //标记是否搜过
int d[4][2] = {{0,1}, {0,-1}, {1,0}, {-1,0}}; //四个方向
int flag;  //用于标记这个岛中是否被完全淹没
void dfs(int x, int y){
    vis[x][y] = 1;      //标记这个'#'被搜过。注意为什么可以放在这里
    if(a[x][y+1]=='#' && a[x][y-1]=='#' && a[x+1][y]=='#' && a[x-1][y]=='#')
        flag = 1;       //上下左右都是陆地，不会淹没
    for(int i = 0; i < 4; i++){ //继续DFS周围的陆地
        int nx = x + d[i][0], ny = y + d[i][1];
      //if(nx>=1 && nx<=n && ny>=1 && ny<=n && vis[nx][ny]==0 && a[nx][ny]=='#') //题目说边上都是水，所以不用这么写了
        if(vis[nx][ny]==0 && a[nx][ny]=='#') //继续DFS未搜过的陆地，目的是标记它们
            dfs(nx,ny);
    }
}
int main(){
    cin >> n;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            cin >> a[i][j];
    int ans = 0 ;
    for(int i = 1; i <= n; i++)  //DFS所有像素点
        for(int j = 1; j <= n; j++)
            if(a[i][j]=='#' && vis[i][j]==0){
                flag = 0;
                dfs(i,j);
                if(flag == 0)  //这个岛全部被淹
                    ans++;     //统计岛的数量
            }
    cout<<ans<<endl;
    return 0;
}
```





# 献给阿尔吉侬的花束

## 模式：BFS

## 关键点

-套模板就是了，特别的地方在于，记录距离使用的是数组，如果来过这个点，那么距离数组中对应的点不为0；

-那么会不会出现记录dist不是最小值的情况呢？不会；因为这是广度优先搜索，总是会把距离起点为X距离的点全部访问一遍先，再访问X+1距离的点；

## 核心代码

```c
typedef pair<int,int> PII;
const int N = 210;
char f[N][N];int dist[N][N];int minn;int r,c;bool flag; //用来判断是否可以到达终点
void bfs(PII start){
    int dx[] = {0,0,-1,1};
    int dy[] = {-1,1,0,0};
    queue<PII> q;
    q.push(start);
    while(!q.empty()){
        auto t = q.front();
        q.pop();
        int sx = t.first,sy = t.second;
        for(int i = 0;i<4;i++){
            int nx,ny;
            nx = sx + dx[i];
            ny = sy + dy[i];
            //判断越界、有障碍、到达终点、走过了
            if(nx>r || ny>c || nx<1 || ny<1 || dist[nx][ny]!=0) continue;
            if(f[nx][ny]=='#') continue;
            if(f[nx][ny]=='E'){
                minn = min(minn,dist[sx][sy]+1);
                flag = true;
                break;
            }
            q.push({nx,ny});
            dist[nx][ny] = dist[sx][sy]+1;
        }}}
int main(){
    int t;
    IOS;
    cin>>t;
    while(t--){
        cin>>r>>c;
        //有多组输入，需要初始化
        memset(f,0,sizeof f);
        memset(dist,0,sizeof dist);
        flag = false;
        minn = 0x3f3f3f3f;
        
        PII start;
        for(int i = 1;i<=r;i++){
            for(int j = 1;j<=c;j++){
                cin>>f[i][j];
                if(f[i][j]=='S') start = {i,j};
            }}
        bfs(start);
        if(flag) cout<<minn<<endl;
        else cout<<"oop!"<<endl;
    }
    return 0;}
```





# 股票买卖Ⅵ

## 模式：状态机DP+贪心

## 关键点

-相较于其它题，本题的情况是可以无限买卖，但增加了“手续费”

## 核心代码

```
int main(){
    int n,f;
    cin>>n>>f;
    memset(dp,0xcf,sizeof dp);
    dp[0][0] = 0;
    for(int i = 1;i<=n;i++){
        int x;
        cin>>x;
        //会不会出现A->B过程中，本来A买入，B卖出最赚钱，但由于程序判断问题，在C时就卖出了？
        //并不会，因为只有卖出然后买入新的的价值 大于 持有不卖的价值时，才会更新dp[1][i]
        //而只要dp[1][i]不更新，那么其实就相当于没有卖出股票并买入新的股票
        //有点骑驴找马的感觉，有一点收益的时候，尝试卖出;
        //但实际上并不更新持有的股票记录
        //当卖出再买入时可能有利可图时（不亏损），就更新dp[1][i]
        dp[0][i] = max(dp[0][i-1],dp[1][i-1]+x-f);
        dp[1][i] = max(dp[1][i-1],dp[0][i-1]-x);
    }
    cout<<dp[0][n]<<endl;
    return 0;
}
```



# 股票买卖Ⅳ

## 模式：状态机DP+贪心

## 关键点

-类比之前写的题目，两笔交易状态数是5，那么k笔交易，状态数就是2k+1，由此写出第一版代码

-但1e5*200的空间复杂度会爆掉，因此采用滚动数组进行优化

-写完参照别人的代码，发现他将2k+1的状态变成了k个状态，用三维数组表示，```dp[N][k][2]```其中1表示持有，0表示空仓；问了AI，我和他未优化前代码应该是一样的，但为什么我爆int了...

但他的代码更能表示出股票买卖的状态机本质，即持有和不持有。这个是我可以参考的。

## 核心代码

```c
/*优化前*/
/*进行k次买卖，则状态总共有2k+1种*/
int main(){
    int n,k;
    cin>>n>>k;
    ll dp[2*k+1][N];
    memset(dp,0xcf,sizeof dp);
    dp[0][0] = 0;
    for(int i = 1;i<=n;i++){
        int x;
        cin>>x;
        dp[0][i] = dp[0][i-1];
        for(int j = 1;j<(2*k+1);j++){
            if(j%2==0) dp[j][i] = max(dp[j][i-1],dp[j-1][i-1]+x);
            else dp[j][i] = max(dp[j][i-1],dp[j-1][i-1]-x);
        }
    }
    ll maxx = 0;
    for(int i = 0;i<=2*k;i+=2) {
        maxx = max(maxx,dp[i][n]);
    }
    cout<<maxx<<endl;
    return 0;
}
/*优化后*/
int main(){
    IOS;
    int n,k;
    cin>>n>>k;
    ll dp[2*k+1];
    ll befor_dp[2*k+1];//等价于dp[j][i-1]
    memset(befor_dp,0xcf,sizeof befor_dp);
    dp[0] = 0;
    ll last = dp[0]; //等价于dp[j-1][i-1]
    for(int i = 1;i<=n;i++){
        int x;
        cin>>x;
        for(int j = 1;j<(2*k+1);j++){
            if(j%2==0) dp[j]= max(befor_dp[j],last+x);
            else dp[j] = max(befor_dp[j],last-x);
            last = dp[j];
            befor_dp[j] = dp[j];
        }
        last = dp[0];
    }
    ll maxx = 0;
    for(int i = 0;i<=2*k;i+=2) {
        maxx = max(maxx,dp[i]);
    }
    cout<<maxx<<endl;
    return 0;
}
/*题解的优化版本
他这里只是加了一个&1
这个思路很通用，所有只用到i-1层的题目都可以这样参考着来写
*/
const int N = 1e5 + 10, M = 110;
int w[N];
int f[2][M][2];
int main()
{
    cin >> n >> k;
    for (int i = 1; i <= n; ++ i) cin >> w[i];
    memset(f, -0x3f, sizeof f);
    f[0][0][0] = 0; //初始状态f[0][0][0]
    for (int i = 1; i <= n; ++ i)
    {
        for (int j = 0; j <= k; ++ j)
        {
            f[i & 1][j][0] = f[(i - 1) & 1][j][0];
            if (j) f[i & 1][j][0] = max(f[i & 1][j][0], f[(i - 1) & 1][j - 1][1] + w[i]);
            f[i & 1][j][1] = max(f[(i - 1) & 1][j][1], f[(i - 1) & 1][j][0] - w[i]);
        }
    }
    int res = 0;
    for (int j = 0; j <= k; ++ j) res = max(res, f[n & 1][j][0]); //目标状态f[n][j][0]
    cout << res << endl;
    return 0;
}
```





# 股票买卖

## 模式：状态机DP+贪心

## 关键点

-与股票买卖Ⅲ本质上是一样的，也是五个状态；

-根据题意，同一天可以进行多次交易，即又买又卖，因此状态转移方程修改为了：

```
dp[0][i] = dp[0][i-1];
dp[1][i] = max(dp[1][i-1],dp[0][i-1]-x);
dp[2][i] = max(dp[1][i]+x,max(dp[2][i-1],dp[1][i-1]+x));
dp[3][i] = max(dp[2][i]-x,max(dp[3][i-1],dp[2][i-1]-x));
dp[4][i] = max(dp[3][i]+x,max(dp[4][i-1],dp[3][i-1]+x));
```

-而这样就会保证不会出现高价买入，卖出时亏本的情况，因为最低也是0，因此输出的时候之间输出```dp[4][n]```即可。

-同样的，提交代码时发现，这题代码与股票买卖Ⅲ的代码是一致的，即不修改交都能AC。。。。细想了一下发现a时买入，b时卖出，b时买入，c时卖出的操作结果，与a时买入，c时卖出是一样的，那两题其实根本就是一题。

-我还发现了状态机的一个好处：它能将状态存储下来，下一步的操作不会影响上一步，随时可以回溯，保证这一步的最优，就能为求出下一步的最优奠定基础，因为可以在此基础上一直迭代。

就比如这题中，```dp[1][i]```就保证了买入时选择的永远是最低的股价，那在后续更新时，基于这个最低的股价，那卖出得到的利润肯定更高。

## 核心代码

```
/*
0:未持有
1:持有
2:持有卖出
3:再次持有
4:第二次卖出
本题特殊之处在于可以在同一天进行多次买卖
*/
int main(){
    IOS;
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        memset(dp,0xcf,sizeof dp);
        dp[0][0] = 0;
        for(int i = 1;i<=n;i++){
            int x;
            cin>>x;
            dp[0][i] = dp[0][i-1];
            dp[1][i] = max(dp[1][i-1],dp[0][i-1]-x);
            //由于可以买卖同一天进行，因此需要比较dp[2][i]-x的结果。
            dp[2][i] = max(dp[1][i]+x,max(dp[2][i-1],dp[1][i-1]+x));
            dp[3][i] = max(dp[2][i]-x,max(dp[3][i-1],dp[2][i-1]-x));
            dp[4][i] = max(dp[3][i]+x,max(dp[4][i-1],dp[3][i-1]+x));
        }
        cout<<dp[4][n]<<endl;
    }
    return 0;
}
```



# 股票买卖Ⅲ

## 模式：状态机DP+贪心

## 关键点

-题目要求买卖两次得到的最大利润，类比Ⅱ的状态机解法，列出多个状态：

```c
    0：没有持有股票
    1：持有股票
    2：进行了第一次交易
    3：已经进行了一次交易且持有股票
    4：已经进行第二次交易
对应的状态转移方程：
    dp[0][i] = dp[0][i-1];
    dp[1][i] = max(dp[1][i-1],dp[0][i-1]-g[i]);
    dp[2][i] = max(dp[2][i-1],dp[1][i-1]+g[i]);
    dp[3][i] = max(dp[3][i-1],dp[2][i-1]-g[i]);
    dp[4][i] = max(dp[4][i-1],dp[3][i-1]+g[i]);
```

-可能就是无法盈利，或者进行一次交易之后就无法盈利了，因此结果为```max(dp[4][n],max(dp[0][n],dp[2][n]))```

-```memset(dp,0xcf,sizeof dp);```相当于初始化为负无穷；

<u>*-这种题目是线性的，即完成一次操作之后，才可进行下一次操作，不能同时进行。因此必然需要联想到线性DP才能解决这个问题。*</u>

## 核心代码

```
/*
为什么没有“进行了一次交易且没有持有股票”这个状态呢？
因为这个状态与dp[2][i-1]相等
*/
int main()
{
    cin >> n;
    memset(dp,0xcf,sizeof dp);
    for(int i = 1; i <= n; ++ i)
    {
        cin >> g[i];
    }
    dp[0][0] = 0;
    for(int i = 1; i <= n; ++ i)
    {
        dp[0][i] = dp[0][i-1];
        dp[1][i] = max(dp[1][i-1],dp[0][i-1]-g[i]);
        dp[2][i] = max(dp[2][i-1],dp[1][i-1]+g[i]);
        dp[3][i] = max(dp[3][i-1],dp[2][i-1]-g[i]);
        dp[4][i] = max(dp[4][i-1],dp[3][i-1]+g[i]);
    }
    cout<<max(dp[4][n],max(dp[0][n],dp[2][n]))<<endl;
}
```





# 股票买卖Ⅱ

## 模式：贪心/可以用DP状态机

## 关键点

-在第1天买，第5天卖，赚到了利润m，那么这个利润m一定小于等于以下的方案：1-5天内，遇到前一天比今天股价便宜的情况就卖出，得到的利润累加为n，n>=m;

-也可以使用DP状态机；

```dp[i][0]```表示前i项的利润最大值，0表示此时没有持有股票；

```dp[i][1]```表示前i项的利润最大值，1表示此时持有股票；

没有持有股票可以有两种情况：①前面就没有持有股票；②前面持有股票但卖了；

持有股票的两种情况：①前面持有股票；②前面没有持有股票，但买了；

## 核心代码

```c
int main(){
    int n;
    cin>>n;
    int ans = 0;
    for(int i = 0;i<n;i++){
        cin>>g[i];
    }
    for(int i = 0;i<n;i++){
        if(g[i]<g[i+1]) ans += g[i+1]-g[i];
    }
    cout<<ans<<endl;
    return 0;
}
/*DP状态机写法：*/
int f[N][2];
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%d", &w[i]);
    f[0][1] = -INF;
    for (int i = 1; i <= n; ++i) {
        f[i][0] = max(f[i - 1][0], f[i - 1][1] + w[i]);
        f[i][1] = max(f[i - 1][1], f[i - 1][0] - w[i]);
    }
    printf("%d\n", f[n][0]);
    return 0;
}
```



# 股票买卖Ⅰ

## 模式：DP+贪心

## 关键点

-```dp[i]```表示前i个里面最大利润，最后结果为最大的```dp[i]```

-扫描一遍数组，动态存储最大值和最小值

## 核心代码

```C
int x;
int n, minn = INT_MAX, maxx = 0;
int main()
{
    cin >> n;
    for(int i = 0; i < n; ++ i)
    {
        cin >> x;
        minn = min(minn, x);
        maxx = max(maxx, x - minn);
    }

    cout << maxx << endl;
}
```



# 错误票据

## 模式：模拟+输入流

## 关键点

-先判断重号，再判断断号

-使用```getline(cin,line)```读取整行输入，随后使用```stringstream```来读取一行中的元素。需要注意的是要用```cin.ignore```去忽略换行符，因为```getline```并不会读取换行符。

## 核心代码

```c
/*难点主要在于读取输入流*/
int main(){
    int n;
    cin>>n;
    cin.ignore();
    int cid,did;
    for(int i = 0;i<n;i++){
        string line;
        getline(cin,line);
        stringstream ss(line);
        int num;
        while(ss>>num){
            ans.push_back(num);
        }}
    sort(ans.begin(),ans.end());
    for(int i = 0;i+1<ans.size();i++){
        if(ans[i]==ans[i+1]) cid = ans[i];
        else if(ans[i]+1!=ans[i+1]) did = ans[i]+1;
    }}
```



# 积木画

## 模式：线性DP+滚动数组优化

## 关键点

-滚动数组是由于对于二维数组来说1e7这个数据范围过大，会爆空间，而题目中又只需要当前状态和前一个状态，因此可以用滚动数组进行优化

-线性DP不知道怎么解释，感觉类似背包问题？

-当前列可以根据对下一列的影响分为三种情况，这三种情况就涵盖了不同积木的摆放方式。而当前列的这三种情况又受上一列的影响。这样依次求下去，最后的```dp[n&1][0]```就为答案。其中&1等价于%2；

## 核心代码

```c
#include<bits/stdc++.h>
using namespace std;
const int MOD = 1000000007;
long long dp[2][3]; //2：代表当前列与下一列的情况；3：代表下一列被占用的格子数：0、1、2；
int main(){
    int n;
    cin>>n;
    dp[1][0] = 1; //一个竖着放
    dp[1][1] = 2; //L
    dp[1][2] = 1; //两个横着放
    for(int i = 2;i<=n;i++){
        dp[i&1][0] = (dp[(i-1)&1][0] + dp[(i-1)&1][2] )%MOD;
        dp[i&1][1] = (dp[(i-1)&1][0]*2 + dp[(i-1)&1][1])%MOD;
        dp[i&1][2] = (dp[(i-1)&1][0] + dp[i-1&1][1])%MOD;
    }
    cout<<dp[n&1][0]%MOD;
    return 0;
}
```



# 整数删除

## 模式：优先队列+链表

## 关键点

-题目特点：进行多次删除操作、动态更新排列顺序、删除之后要增加数的大小会导致还在堆中的元素的权的变化

-多次删除->用链表；

-动态更新排列顺序->用优先队列

->大小顺序会改变但要持续删除最小值->增加一个判断，若数的值改变了，则把取出来的数又丢回去排列

## 核心代码

```c
void del(int x) {
    r[l[x]] = r[x], l[r[x]] = l[x];
    a[l[x]] += a[x], a[r[x]] += a[x];
}
int main(){
    cin>>n>>k;
    r[0] = 1;l[n+1] = n;
    priority_queue<pair<ll,int>,vector<pair<ll,int>>,greater<pair<ll,int>> > h;
    for(int i = 1;i<=n;i++){
        cin>>a[i];
        l[i] = i-1,r[i] = i+1;
        h.push({a[i],i});
    }
    while(k--){
        auto p = h.top();
        h.pop();
        if(p.first!=a[p.second]){
            h.push({a[p.second],p.second});
            k++;
        }
        else del(p.second);
    }
    int head = r[0];
    while(head != n+1){
        cout<<a[head]<<" ";
        head = r[head];
    }
    return 0;
}
```











# 质数与闰年

质数：只能被1和本身整除的数为质数，且1和0既不是质数也不是合数

```c
bool isprime(int x){
	if(x<=1) return false;
	if(x==2 || x==3) return true;
	if(x%6!=1&&x%6!=5) return false;
	for(int i = 5;i*i<=x;i+=6){
		if(x%i==0) return false;
	}
	return true;
}
```

闰年：对于年份较小的数，能被4整除且不能被100整除，或者能被四百整除的数为闰年年份；对于非常大的年份，如果年份能被3200整除且能被172800整除，则是闰年（这里不考虑）

```C
bool judge(int y){
	if(y%400==0) return true;
	if(y%4==0&&y%100!=0){
		return true;
	}
	return false;
}
```







# 逛画展

## 模式：双指针+队列

## 关键点

```
（1）定义l、r两个指针，定义k用于记录看到的画种数，k<m时，r不断右移，将指向的元素推入数组record中
（2）k==m时，记录此时l与r的差值
（3）将l右移1位，减去record相应的数，随后查看是否满足（2），若满足继续执行（2）(3)否则执行（1） 
```

## 核心代码

```
int l = 0;
	int r = 0;
	int diff = 0x7fffffff;
	record[p[0]]++;
	int k = 1;
	int record_l;
	int record_r;
    while(r<n){
    	if(k==m){
    		if(diff>r-l){
    			diff = r-l;
    			record_l = l;
    			record_r = r;
			}
    		record[p[l]]--;
    		if(record[p[l]]==0) k--;
    		l++;
		}
    	else{
    		r++;
    		if(record[p[r]]==0) k++;
    		record[p[r]]++;
		}
    	
	}
    cout<<record_l+1<<" "<<record_r+1<<endl;
```





# 最长上升子序列

最长上升子序列可以看成是求两个相同序列的最大上升公共序列

## 模式：贪心+二分（nlogn）

## 关键点

```
（1）初始化：记录最长上升子序列数组f，f[1] = a[1];
（2）更新长度：满足f[flen]<a[i] f[++flen] = a[i];
（3）替换：不满足（2）的条件则用二分查找到f中，第一个大于a[i]的数进行替换
说明：（3）执行过后得到的子序列不一定是正确的子序列，但它不会增加或者减少序列长度，只是记录了一种可能性，保证能求出正确的len
```

## 核心代码

```
int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		f[i]=0x7fffffff;
	}
	f[1]=a[1];
	int len=1;
	for(int i=2;i<=n;i++)
	{
		int l=0,r=len,mid;
		if(a[i]>f[len])f[++len]=a[i];
		//如果刚好大于末尾，暂时向后顺次填充 
		else 
		{
		while(l<r)
		{	
		    mid=(l+r)/2;
		    if(f[mid]>a[i])r=mid;
			else l=mid+1; 
		}
		f[l]=min(a[i],f[l]);//更新最小末尾 
     	}
    }
    cout<<len;
```





# 最长公共子序列

## 模式：线性DP（n²） / 贪心+二分（nlogn）

## 关键点

```
#对于动态规划
对于两个字符串s、t，有选/不选si，选/不选ti组合而成的四种情况
dp[i][j]:数组s的前i项和字符串t的前j项的子序列长度
状态转移：dp[i][j] = max(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+(s[i]==t[j]? 1:0));

#对于贪心＋二分
（1）将其中一个数组的数值和数组下标进行一个映射mapp[a[i]] = i;
（2）能组成公共子序列的条件是目前的子序列的下标最大值f[flen]<要加入的数的下标值mapp[t[i]]
满足条件即可加入
（3）若不满足条件，则在f中用二分查找出第一个大于mapp[t[i]]的f[l]值，并替换
```

## 核心代码

```
int dp[N];
int s[N];
int t[N];
int f[N];
int mapp[M];
int main(){
    int len;
	cin>>len; 
    for(int i = 1;i<=len;i++){
    	cin>>s[i];
    	mapp[s[i]] = i; //记录s[i]的最大下标数 
	}
    for(int i = 1;i<=len;i++){
    	cin>>t[i];
    	f[i] = 0x7fffffff;
	}
	
/*
会超时 
    for(int i = 1;i<=len;i++){
    	int pre = 0;
    	for(int j = 1;j<=len;j++){
    		int temp = dp[j];
    		if(s[i]==t[j]) dp[j] = pre + 1;
    		else{
    			dp[j] = max(dp[j],dp[j-1]);
			}
			pre = temp;
		}
	}
    
    cout<<dp[len]<<endl;
*/
	int flen = 0;
	for(int i = 1;i<=len;i++){
		if(mapp[t[i]]>f[flen]) f[++flen] = mapp[t[i]]; //若记录的最后一个数的下标比要加入的数小，则可以加入 
		else{ //反之则查找进行替换 
			int l = 0;
			int r = flen;
			while(l<r){
				int mid = (l+r)/2;
				if(mapp[t[i]]<f[mid]) r = mid; //找到f中能被替换的下标的最大值，即偏右的 
				else l = mid +1;
			}
			f[l] = min(f[l],mapp[t[i]]);
		}
	
	} 
}
```



# 进制转换

## 模式：高精度+进制位+短除法

## 关键点

```
1.对于位数较小的进制转换(对于0需要特判)
# x%进制数为低位的2进制数 x = x/进制数作为下一次循环的输入
# 多次循环之后就可以输出结果
void printf(LL x){
	if(x==0){
		return;
	}
	int temp = x%2;
	printf(x/2);
	cout<<temp;
	return;
}
2.对于位数较多的数
#首先需要使用字符串或者数组存储
#为方便体现进制，需要从高位开始进行运算
vector<int> printf(vector<int> &C,int &r,int x){ //r代表C除以2之后的余数 
	r = 0;
	vector<int> A; //A存放模拟一次C除以2之后的商的结果 
	for (int i = C.size() - 1; i >= 0; i -- )
	{
		r = r*10 + C[i];
		A.push_back(r/x);
		r = r%x; //除完之后的余数进入下一位 
	}
	reverse(A.begin(), A.end()); //翻转，使得高位数组下标更大
	while(A.size()>1 && A.back()==0) A.pop_back(); //去除无意义的前导0
	return A;
}
```

## 核心代码

```c
vector<int> printf(vector<int> &C,int &r,int x){ //r代表C除以2之后的余数 
	r = 0;
	vector<int> A; //A存放模拟一次C除以2之后的商的结果 
	for (int i = C.size() - 1; i >= 0; i -- )
	{
		r = r*10 + C[i];
		A.push_back(r/x);
		r = r%x; //除完之后的余数进入下一位 
	}
	reverse(A.begin(), A.end());
	while(A.size()>1 && A.back()==0) A.pop_back();
	return A;
}

int main(){
	IOS;
	string s;
	while(cin>>s){
		vector<int> A;
		for(int i = s.size()-1;i>=0;i--){
			A.push_back(s[i]-'0');
		}
		vector<int> res; //用于存放ans 
		int r = 0;
		vector<int> C;
		C = printf(A,r,2);
		while(1){
		//每次循环都可以得到一个位数，本质上就是模拟x/进制数 x%进制数 这个基本转换过程
		//只不过由于存储的数据结构为数组，因此复杂一些
			res.push_back(r);
			if(C.size()==1 && C[0]==0) break;
			C = printf(C,r,2);
		}
		for(int i = res.size()-1;i>=0;i--){
			cout<<res[i];
		}
		puts("");
	}
	return 0;
}
```



# 数对

## 模式：双指针（有点特别）

## 关键点

-考虑会爆int，一定要记得开long long

-使用l、r1、r2三个指针去遍历数组，r2和r1之间的数据为满足条件的数据，答案为ans+=r1-r2

## 核心代码

```
	if(n==1){
    	cout<<0<<endl;
    	return 0;
	}
	sort(a,a+n);
    int l = 0,r1 = 1,r2=1;
    ll ans = 0;
    for(l=0;l<n;l++){
    	while(a[r1]-a[l]<=c && r1<n) r1++;
    	while(a[r2]-a[l]<c && r2<n) r2++;
    	if(a[r2]-a[l]==c && a[r1-1]-a[l]==c){
    		ans += r1-r2;
		}
    	
	}
```



# 打鼹鼠

## 模式：线性DP（n²）

## 关键点

-双重循环，表示由j到i的能打到的鼹鼠数量，i表示在位置i能打到的鼹鼠的最大值

-状态转移：dp[i] = max(dp[i],dp[j]+1)

## 核心代码

```
for(int i = 1;i<=m;i++){
    	dp[i] = 1;
    	for(int j = 1;j<i;j++){
    		int diff = abs(p[i].x-p[j].x) + abs(p[i].y-p[j].y);
    		if(diff<=(p[i].t-p[j].t)){
    			dp[i] = max(dp[i],dp[j]+1);
			}
    		
			ans = max(ans,dp[i]);
		}
	}
```



# 最厉害的学生

## 模式：模拟+排序

## 关键点

-使用结构体存储数据，然后利用sort排序

-但这里要注意sort排序是不稳定排序，即不可以保证total相同的情况下，总是排名靠前的排在前面，因此要加一个order去保证

## 核心代码

```
bool cmp(student &s1,student &s2){
	return s1.total>s2.total || (s1.total==s2.total&&s1.order<s2.order);
}
...
sort(students,students+n,cmp);
	
cout<<students[0].name<<" "<<students[0].chinese<<" "<<students[0].math<<" "<<students[0].english<<endl;
```



# 求阶乘和

## 模式：递归

## 核心代码

```
int dfs(int x){
	if(x==1) return 1;
	else return x*dfs(x-1);
}
```



# 赦免战俘

## 模式：模拟+位运算

## 关键点

-使用位运算求解的话，关键在于发现 i|j的值等于(1<<n)-1的时候，战犯不会被赦免；

-但也可以用递归模拟这个过程

## 核心代码

```
//我写的递归模拟代码
void dfs(int x,int si,int sj){
	if(x==0) return;
	int h = pow(2,x-1); 
	for(int i = si;i<si+h;i++){
		for(int j = sj;j<sj+h;j++){
			p[i][j] = 1;
		}
	}
	dfs(x-1,si,sj+h); //往矩阵的另外三个方向去扩展
	dfs(x-1,si+h,sj+h);
	dfs(x-1,si+h,sj);
}
//别人的位运算代码
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
	scanf("%d",&n);
	for(int i=0;i<(1<<n);i++){ //(1<<n)相当于求2的n次方
		for(int j=0;j<(1<<n);j++){
			printf("%d ",(i|j)!=((1<<n)-1)?0:1);}
		printf("\n");}
	return 0;}
```



# 评等级

## 模式：练习结构体

## 关键点

-结构体最重要的作用就是绑定，即将一个对象的多个属性或者一个问题的多个要素，关联到一起，简化代码逻辑

-在结构体中定义函数，可以直接调用结构体中定义的变量，表示的是该结构体的该对象的属性

## 核心代码

```
struct student{
	int id,score1,score2,mix_score;
	int getScore(){
		return score1+score2;
	}
	
}students[1010];

void calcScore(student &s){
	int mix_score = s.score1*7+s.score2*3;
	s.mix_score = mix_score;
}
```







# 移动距离

## 模式：模拟

## 关键点

-计算曼哈顿距离

## 核心代码

```
	m--;
	n--; 
    int x1 = m/w; //计算行号
    int x2 = n/w;
    int y1 = m%w; //计算列号
    int y2 = n%w;
    if(x1 & 1) y1 = w-1-y1; //如果是奇数行就转换一下
    if(x2 & 1) y2 = w-1-y2;
    cout<<abs(x1-x2) + abs(y1-y2)<<endl;
```



# 红与黑

## 模式：dfs+flood fill

## 关键点

-因为有多组输入，因此需要重置数组

-不需要恢复现场，走过了就是走过了，有点像bfs

-要进行是否有起始位置的判断（即是否有‘@’字符的砖块）

## 核心代码

```
void dfs(int sx,int sy){
	cnt++;
	int dx[]={0,0,-1,1};
	int dy[]={-1,1,0,0};
	st[sx][sy] = 1;
	for(int i = 0;i<4;i++){
		int nx = sx + dx[i];
		int ny = sy + dy[i];
		//排除越界、走过、不是黑格的情况 
		if(nx<1 || nx>n || ny<1 || ny>m) continue;
		if(st[nx][ny]) continue;
		if(p[nx][ny]!='.') continue;
		
		st[nx][ny] = 1;
		dfs(nx,ny);
		
	}
	return;
}
...
memset(p,0,sizeof p);
    	memset(st,0,sizeof st);
	    if(m!=0&&n!=0){
	    	for(int i = 1;i<=n;i++)
	    		for(int j = 1;j<=m;j++){
	    			cin>>p[i][j];
	    			if(p[i][j]=='@'){
	    				sx = i;
	    				sy = j;
	    				flag = true;
					}
				}
			if(!flag){
			    break;
			}
	    	dfs(sx,sy);
	    	cout<<cnt<<endl;
		}
```





# 岛屿个数

## 模式：BFS

## 关键点

-存取数据从数组下标1开始存储

-进行bfs遍历时从(0,0)开始遍历，并且判断边界为0-(n+1)，这样做是防止卡图

-对于海水，探索它的所有方向，若找到岛屿了，则把该岛屿相邻的所有岛屿都标记了

-对于在环内的数据，是不会被从外围开始遍历的搜索方式搜索到的 

## 核心代码

```
void bbfs(int sx,int sy){
	cnt++;
	int dx[] = {0,0,-1,1};
	int dy[] = {-1,1,0,0};
	queue<PII> q;
	q.push({sx,sy});
	st[sx][sy] = 1;
	while(q.size()){
		auto t = q.front();
		q.pop(); //处理根节点的子节点 
		for(int i = 0;i<4;i++){
			int nx = t.first +dx[i];
			int ny = t.second +dy[i];
			if(!st[nx][ny] && nx>=0 && ny>=0 && nx<=n+1 && ny<=m+1){
				if(p[nx][ny]=='1'){
					q.push({nx,ny});
					st[nx][ny] = 1;
				}
				
			}
		}
	}
	
} 


void bfs(int sx,int sy){
	int dx[] = {0,0,-1,1,-1,-1,1,1};
	int dy[] = {-1,1,0,0,-1,1,-1,1};
	queue<PII> q;
	q.push({sx,sy});
	st[sx][sy] = 1;
	while(q.size()){
		auto t = q.front();
		q.pop(); //处理根节点的子节点 
		for(int i = 0;i<8;i++){
			int nx = t.first +dx[i];
			int ny = t.second +dy[i];
			if(!st[nx][ny] && nx>=0 && ny>=0 && nx<=n+1 && ny<=m+1){
				if(p[nx][ny]=='1') bbfs(nx,ny); //如果找到了岛屿则遍历岛屿 
				else{
					q.push({nx,ny});
					st[nx][ny] = 1;
				}
			}
		}
	}
}
...
while(T--){
		cnt = 0;
		memset(st,0,sizeof st);
		memset(p,0,sizeof p);
		cin>>n>>m;
		for(int i = 1;i<=n;i++){
			for(int j = 1;j<=m;j++) cin>>p[i][j];
		}
		bfs(0,0);
		cout<<cnt<<endl;
	} 
```





# 数字接龙

## 模式：dfs

## 关键点

-有多个答案按字典序输出答案，那么就只需要最开始就遍历“01234567”代表的方向，然后找到答案之后输出第一个答案即可

-判断是否有交叠，则创建一个四维矩阵edge，表达从（a，b）到（x，y）的路径。再利用这个矩阵判断即可

-路径用字符串存储，方便传递

-创建dx和dy数组表达方向，优化代码结构

## 核心代码

```
bool check(int a,int b,int x,int y){
	
	if(edge[x][b][a][y]||edge[a][y][x][b]) return false;
	return true;
}

void dfs(int x,int y,string path){
	if(first) return;
	if(x==n&&y==n&&path.size()==n*n-1){
		ans = path;
		first = true;
		return;
	}
	int dx[8]={-1,-1,0,1,1,1,0,-1};
    int dy[8]={0,1,1,1,0,-1,-1,-1};
	string paths = "01234567";
	int now = p[x][y];
	st[x][y] = 1;
	for(int i=0;i<8;i++){
		int nx = x+dx[i];
		int ny = y+dy[i];
		//判断越界
		if(nx>n || nx<1 || ny>n || ny<1) continue;
		//被访问过了或者不满足now的要求 
		if(st[nx][ny]|| (now+1)%k!=p[nx][ny]) {
			continue;
		}
		//有交叉边 
		if(!check(x,y,nx,ny)){
			continue;
		}
		edge[x][y][nx][ny] = 1;
		edge[nx][ny][x][y] = 1;
		string temp = path;
		path += paths[i];
		st[nx][ny] = 1;
		dfs(nx,ny,path);
		//恢复现场
		st[nx][ny] = 0;
		edge[x][y][nx][ny] = 0;
		edge[nx][ny][x][y] = 0;
		path = temp; 
	}
}
```











# 01背包问题

## 模式：动态规划

## 关键点

-前i个物品，总容量为j时的价值

-分为选和不选两种情况，求最大值

## 核心操作

```
//二维写法 n是货物数，v是背包体积，a[]是物品体积,va[]是物品价值
for(int i = 1;i<=n;i++){
	for(int j = 1;j<=v;j++){
	if(j<a[i]) dp[i][j] = dp[i-1][j];
	else dp[i][j] = max(dp[i-1][j-a[i]] + va[i],dp[i-1][j]);
	}
}
cout<<dp[n][v]<<endl;


//一维数组
//为什么能用一维数组代替？因为dp[i][j]更新依赖于dp[i-1][j]，即只与上一层有关，因此可以简化
//为什么一维数组版本，j一定要逆序更新？因为dp[j]依赖于dp[j-a[i]]，而j>j-a[i],如果从小往大更新的话，dp[j-a[i]]会先被更新，那么dp[j]就无法正确更新了，因为要想正确更新，dp[j]必须依赖上一层的dp[j-a[i]]

for(int i = 1;i<=n;i++){
	for(int j = v;j>=a[i];j++){
	dp[j] = max(dp[j-a[i]] + va[i],dp[j]);
	}
}
cout<<dp[j]<<endl;
```



# 二位费用的背包问题

## 模式：动态规划

## 关键点

-仿照01背包问题，扩展成三维即可

## 核心代码

```
for(int i = 1;i<=n;i++){
        for(int j =0;j<=v;j++){
            for(int k = 0;k<=m;k++){
                if(j>=iv[i]&&k>=im[i]){
                    dp[i][j][k] = max(dp[i-1][j][k],dp[i-1][j-iv[i]][k-im[i]] + w[i]);
                }
                else dp[i][j][k] = dp[i-1][j][k];
            }
        }
    }
```





# 多重背包问题

## 模式：动态规划+二进制优化+单调队列优化

## 关键点

-对于数据量较小的题目，可以将其转化成01背包问题

-对于数据量较大的题目，需要采用二进制的方式去构造新背包，优化时间复杂度

-对于数据量巨大的题目，需要用队列对物品进行排序，优化操作

## 核心操作

```
//二进制可以表示出任何一个十进制数，那么我想取的任何一个数量N，都可以通过选取多个构造出的组来实现
for(int i =1;i<=n;i++){
        int vv,ww,s;
        cin>>vv>>ww>>s;
        int k = 1;
        while(k<=s){
            count++;
            v[count] = vv*k;
            w[count] = ww*k;
            s = s-k;
            k = k*2;
        }
        if(s>0){ //此时只剩一组
            count++;
            v[count] = vv*s;
            w[count] = ww*s;
        }
    }
之后按照01背包模式处理v和w数组即可得到答案
```



# 完全背包问题

## 模式：动态规划

## 关键点

-只能正序更新，且值依赖于本层元素

-dp【i-1】【j】= max(dp【i-1】【j】,dp【i】【j-c[i]】+w[i]);

## 核心操作

```
//相比于01背包问题，完全背包问题只能正序
//因为dp[i][j]值的更新要依赖于本层的元素，所以要从前往后依次更新
//而01背包问题dp[i][j]值依赖于上一层，因此二维数组情况下，其正逆序都可以
for(int i = 1;i<=n;i++){
		for(int j = 1;j<=v;j++){
			if(j<c[i]) dp[i][j] = dp[i-1][j];
			else dp[i][j] = max(dp[i-1][j],dp[i][j-c[i]]+w[i]);
			//01背包问题：
			//dp[i][j] = max(dp[i-1][j],dp[i-1][j-c[i]]+w[i]);
		}
	}
	cout<<dp[n][v]<<endl;
=======================================================
for (int i = 1; i <= n; i ++ )
        for (int j = v[i]; j <= m; j ++ ) // 完全背包 一维 只能 正序更新
        // 01背包 一维 只能 逆序更新: for (int j = m; j >= v[i]; j -- )
            f[j] = max(f[j], f[j - v[i]] + w[i]);
	
```

# 分组背包问题

## 模式：动态规划

## 核心操作

```
for(int i = 1;i<=n;i++){
		for(int j = 1;j<=v;j++){
			df[i][j] = df[i-1][j]; //不选
			for(int k = 1;k<=s[i];k++){
			if(j>=c[i][k]) df[i][j] = max(df[i][j],df[i-1][j-c[i][k]]+w[i][k]);
			}
		}
	}
```





# 最长上升子序列

## 模式：动态规划（时间复杂度n²）

## 关键点

-创建df数组，存储每个数的最长子序列

-初始化df数组为1，因为每个数独自构成一个长度为1的子序列

## 核心操作

```
// 由于只关心最长上升子序列的长度
// 并且计算以某一个数结尾的最长子序列时，只关系其前一个数的大小是否大于它
// 只需要满足这个数大于其前一个数，并且子序列长度尽可能长就行了
	for(int i =0;i<n;i++){
		for(int j = 0;j<i;j++){
			if(a[j]<a[i]){
				df[i] = max(df[j]+1,df[i]);
			}
		}
		if(ans<df[i]) ans = df[i];
	}
```

# 连续子数组的最大和

## 模式：动态规划+贪心（时间复杂度n）

## 关键点

-对于一个数有两种操作：一个是加上，一个是以它为起始

-df数组：以i结尾的连续数组的最大和

## 核心操作

```
//嘿嘿这是自己写的，空间复杂度O（1），比题解好，虽然题解的思路更清晰
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int maxx = -201;
        int temp = 0;
        for(int i = 0;i<nums.size();i++){
            if(temp<0){
                if(nums[i]>temp) temp = nums[i];
            }
            else temp +=nums[i];
            if(maxx<temp) maxx = temp;
        }
        return maxx;
    }
};
```





# （待填的坑）

模式：贪心+二分





# 地宫寻宝

## 模式：动态规划（四维）

## 关键点

-开四维数组记录

```
df[i][j][cnt][c]表示在i，j位置下，拿取了cnt个物品，其中物品价值最高的是c的方案数
```

-初始化最开始的位置为1

-物品价值都加加，这样最低的物品价值为1，就可以使用0来记录初始的价值

-进行加法运算的时候，要mod一下，不能全加起来一起mod，可能会超出范围

## 核心操作

```
for(int i = 1;i<=n;i++){
		for(int j = 1;j<=m;j++){
			for(int p = 0;p<=k;p++){ //i,j位置下拿取0-k件物品的方案 
				for(int q = 0;q<M;q++){ //i,j位置下，最大价值为q的方案 
					//不拿取 状态平移，就位置改变了其他都不变，没有增加物品，也没有减少物品
					f[i][j][p][q] =  (f[i][j][p][q] + f[i-1][j][p][q]) %MOD; // 从上来的 
					f[i][j][p][q] =  (f[i][j][p][q] + f[i][j-1][p][q]) %MOD; // 从右来的 
					//拿取 拿取当前位置的物品，因此q要等于s[i][j],或者倒不如说是因为拿取当前位置的物品=>当前最大物品等于当前位置的物品 
					if(q==s[i][j]&&p>0){
						for(int l =0;l<q;l++){
							f[i][j][p][q] = (f[i][j][p][q] + f[i-1][j][p-1][l]) %MOD;
							f[i][j][p][q] =  (f[i][j][p][q] + f[i][j-1][p-1][l]) %MOD;
						}
					}
				}
			}
		}
	}
```

# 波动数列

## 模式：动态规划（数学转换）（时间复杂度n²）

## 关键点

-将问题转换成求前i个a或者b相加等于j的方案数

-初始化df【0】【0】为1

-结果输出df【n-1】【s%n】

## 核心操作

```
	for(int i = 1;i<n;i++){
		for(int j = 0;j<n;j++){
			df[i][j] = (df[i-1][get_mod(j- (n-i)*a,n)] + df[i-1][get_mod(j+(n-i)*b,n)]) %MOD ;
		}
	}
```

## 相关题目

01背包问题



# 垦田计划

## 模式：二分（时间复杂度nlogn）

## 关键点

-想出直接拿一个天数去判断在现有的资源下，能否使相应的土地在这个天数下完成，若可以就期待更快，若不可以则尝试更慢，最后找到正确答案

-怕超出范围所以（l+r）/2写成l + (r-l)/2;

## 核心操作

```
while(l<r){
		int mid = l + (r-l)/2;
		
		if(check(mid)){ //如果能实现，那就期待更小的天数 
			r = mid;
		}
		else l = mid+1; 
	}
	cout<<l<<endl;
```

# 二分模板

1.左开右闭(l,r]

```
l=0;r=n-1;
while (l < r){
    mid=(l+r)/2;
    if (check(mid)) r=mid;
    else l=mid+1;
}
考虑只剩下两个元素的情况,此时mid指向左边的元素,而闭合的为右边,因此不会造成死循环.
```

2.左闭右开[l,r)

```
l=0;r=n-1;
while (l < r){
    mid=(l+r+1)/2;
    if (check(mid)) l=mid;
    else r=mid-1;
}
考虑只剩下两个元素的情况,此时mid指向右边的元素,而闭合的为左边,因此不会造成死循环.
(若mid=(l+r)/2,则指向左边的元素,而闭合也在左边,因此会造成死循环.)
```







# 牛奶交换

## 模式：模拟+双指针（时间复杂度n）

## 关键点

-找到会发生溢出的情况：左右两边都往这个位置传递牛奶会发生溢出

-找出溢出量：根据这个位置的传递方向，求相反方向的区间的子段和

-更抽象的想法是转换成图，如果是环则不会溢出，否则从链首开始溢出

## 核心操作

```
//基础做法
while(l!=n){
        if(op[l]=='R'&&op[r]=='L'){
            int idx = (r-1 + n)%n;
            if(op[idx]=='R'){
                ll temp_sum = 0;
                int temp_idx = l;
                while(op[temp_idx]!='L' &&temp_sum<m){
                    temp_sum += a[temp_idx];
                    temp_idx = (temp_idx-1 + n)%n;
                }
                sum -= min(temp_sum,m);
            } 
            else {
                ll temp_sum = 0;
                int temp_idx = r;
                while(op[temp_idx]!='R'&& temp_sum<m){
                    temp_sum += a[temp_idx];
                    temp_idx = (temp_idx+1 - n)%n;
                }
                sum -= min(temp_sum,m);
            }
        }
        l++;
        r++;
        if(r==n){
            r = 0;
        }
    }
//图论
for(int i = 0; i < n; i ++) 
    {
        if(s[i] == 'L') din[(i - 1 + n) % n]++;
        else din[(i + 1) % n] ++;
    }
    auto dfs = [&](auto self, int u) -> i64
    {
        if(din[u] > 1) return 0; // 如果一个点的入读 > 1，说明这是一个环的入口，也是链的终点
        return a[u] + self(self, s[u] == 'L' ? (u - 1 + n) % n : (u + 1) % n);
    };
    i64 ans = 0;
    for(int i = 0; i < n; i ++)
    {
        if(din[i] == 0) // 枚举所有链的起点
            ans += min(m, dfs(dfs, i)); // 累加损失之和
    }
```



# 统计子矩阵

## 模式：双指针+前缀和+枚举

## 关键点

-将矩阵数据用前缀和存储起来

-如果使用前缀和，最好计数的时候从1开始，而不是从0开始

## 核心代码

```
pre[i][j] = pre[i][j] + pre[i][j-1] + pre[i-1][j] - pre[i-1][j-1];
for(int i = 1;i<=m;i++){
        for(int j = i;j<=m;j++){//每次循环：想象成切割出相同的行数，不同列数的矩阵
            for(int s = 1,t = 1;s<=n;s++){ //每次循环：想象成切割出不同行数，相同列数的矩阵
                
                while(s>=t && pre[s][j] - pre[t-1][j] - pre[s][i-1] + pre[t-1][i-1] > k ) t++;
                if(s>=t){
                    ans += s-t+1;
                    // cout<<s<<" "<<t<<endl;
                }
            }
        }
    }
```



# 好数

## 模式：暴力枚举

## 关键点

-将一个int的整数的每一位取出来存在数组中，根据题目判断每一位是否满足要求

-暴力枚举1-n的数

## 核心代码

```
bool check(int m){
	int nums[8];
	int len = 0;
	while(m){
		int temp = m%10;
		nums[len] = temp;
		m = m/10;
		len++;
	}
	
	for(int i = 0;i<len;i++){
		if(i%2==nums[i]%2) return false;
	}
	return true;
}
```



# 拔河

## 模式：暴力枚举+前缀和

## 关键点

-观察数据范围为1e3，因此可以使用二重循环遍历

-若题目要用到前缀和，那记录数据的时候下标从1开始，不然会有点麻烦

-先计算出所有可能的区间和，再进行排序，最小值一定产生于排序后的相邻的数相减，此时要考虑这两个数代表的区间会不会有重复的数

①没有重复的数

②有一部分重复，有一部分没有重复；这种情况重复的部分可以视作两个区间都没选

③一个区间包含另外一个区间，这种情况就不可取，需要排除

-计算所有区间时，不要把所有数都放进去了，因为题目是要两个队伍，这种情况只会产生一个队伍。（其实也可以不判断，因为此时这个区间包含所有区间，相当于③，会被排除）

## 核心代码

```
bool check(int a,int b,int a1,int b1){
    if((a>=a1&&b<=b1)||(a<=a1&&b>=b1)) return false;
    return true;
}
...
for(int i = 1;i<=n;i++){
        pre[i] = a[i] + pre[i-1];
    }
    int p_len = 0;
    for(int i = 1;i<=n;i++){
        long long s = 0;
        for(int j = i;j<=n;j++){ //计算所有区间的力量值，除了一个队伍的情况
            if(j == n && i ==1) continue;
            s = pre[j] - pre[i-1];
            p[p_len].sum = s;
            p[p_len].r = j;
            p[p_len].l = i-1;
            p_len++;
        }
    }
    sort(p,p+p_len,cmp);
    for(int i = 0;i<p_len-1;i++){
        // cout<<p[i].l<<" "<<p[i].r<<" "<<p[i+1].l<<" "<<p[i+1].r<<endl;
        if(check(p[i].l,p[i].r,p[i+1].l,p[i+1].r)) minn = min(minn,p[i+1].sum-p[i].sum);
    }
    
```



# R格式

## 模式：高精度

## 关键点

-用字符串存取数字

-将存取的数字倒置，让高位位于尾部，方便进行进位操作（只需要将进位值push_back即可）



## 核心操作

```
void mul(int b){
    int t = 0 ;
    for(int i = 0;i<handle.size();i++){
        t += handle[i]*b;
        handle[i] = t%10;
        t /= 10;
    }
    if(t) handle.push_back(t);
}
void add(int idx){
    int t = 1;
    for(int i = idx;i<handle.size();i++){
        t += handle[i];
        handle[i] = t%10;
        t /=10;
    }
    if(t) handle.push_back(t);
}
	reverse(s.begin(),s.end());
    int idx = s.find('.');
    s.erase(idx,1);
    for(int i = 0;i<s.size();i++) handle.push_back(s[i]-'0');
    for(int i = 0;i<n;i++) mul(2); //不进行多次循环的话会超过数据范围
    // mul(tn);
    if(handle[idx-1]>=5) add(idx);
    for(int i = handle.size()-1;i>=idx;i--){
        cout<<handle[i];
    }
    cout<<endl;
```



# 回文日期

## 模式：模拟

## 关键点

-判断闰年条件：能被4整除但不能被100整除，或者被四百整除

-直接根据要求，枚举出年份，然后进行构造，再判断是否合法即可

-每年最多只有一个回文日期

## 核心代码

```
//因为还没从高精度那一题缓过来。。所以用的是数组存储数据
//首先还要判断给的日期是否满足题意，因为题目要求的是下一个回文日期
if(check() || cmp()) add();
while(1){
            ss[4] = ss[3];
            ss[5] = ss[2];
            ss[6] = ss[1];
            ss[7] = ss[0];
            if(ok()){ //ok函数判断是否合法
            	print();
                break;
            }
            add();
        }
        while(1){
			if(ss[2]==ss[3]) add(); //这里把ss写成s坑死我了。。。debug快一小时。。
            ss[4] = ss[3];
            ss[5] = ss[2];
            ss[6] = ss[1];
            ss[7] = ss[0];
            if(ok()){
            	if(ss[0]==ss[2] && ss[1]==ss[3]){
            		print();
					break;
				}
            }
            add();
        }
```



# 日期问题模板

```
#include <iostream>
using namespace std;

int months[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

// 判断日期的合法性
bool check_valid(int date) //形如20210305
{
    int year = date / 10000;
    int month = date % 10000 / 100;
    int day = date % 100;

    if (month <= 0 || month >= 13) return false;
    if (day == 0 || month != 2 && day > months[month]) return false;

    if (month == 2)
    {
        int leap = (year % 4 == 0 && year % 100 != 0 || year % 400 == 0);
        if (day > 28 + leap) return false;
    }

    return true;
}

// 得到某年某月的天数
int get(int year, int month) 
{
    if (month != 2) return months[month];
    else
    {
        // 2月
        int leap = (year % 4 == 0 && year % 100 != 0 || year % 400 == 0);
        return 28 + leap;
    }
}

// 判断两个日期之间有多少个回文日期
int get(int date1, int date2, int k) //k使函数签名不同从而编译通过
{
    int ans = 0;
    for (int i = 1000; i < 10000; i++)
    {
        int date = i, x = i;
        for (int j = 0; j < 4; j++) date = date * 10 + x % 10, x /= 10; //根据年份构造出回文日期
        if (date1 <= date && date <= date2 && check_valid(date)) ans++; 
    }

    return ans;
}

// 给定年月日，经过n天后对应的日期
void pass(int y, int m, int d, int n)
{
    while (n--)
    {
        d++;
        if (d > get(y, m)) m++, d = 1;
        if (m > 12) y++, m = 1;
    }
    printf("%d-%02d-%02d\n", y, m, d);
}

int main()
{
    return 0;
}
```



# 外卖店优先级（卡了N久...）

## 模式：模拟

## 关键点

-优先级小于0置0

-先判断是否要移除优先级列表，再考虑是否要加入

-对外卖订单根据时间排序

-需要更新优先级的时刻： ①那家店来了新的订单 ②到达了时刻t 

-需要记录的数据：①优先级 ②上一次到达订单的时间 

## 核心代码

```
bool cmp(const pair<int, int>& a, const pair<int, int>& b) {
    return a.first < b.first || a.first == b.first && a.second < b.second;
}
//对输入进行排序
	sort(order.begin(),order.end(),cmp);
//如果存储在数组里而不是容器里则：sort(order,order+m,cmp);
    for(int i = 0;i<m;i++){
		....
		//先判断是否排出队列
    	priority = max(priority-diff,0);
    	if(priority<4) v.erase(id);
    	priority += 2;
    	//再判断是否加入队列
    	if(priority>5) v.insert(id);
    	store[id].first = priority;
    	store[id].second = ts;
	}
    for(auto it = v.begin();it!=v.end();++it){
    	... //遍历集合，得出最后结果
	}
```



# 宝石组合

## 模式：数论+最大公约数+推公式

## 关键点

①ab = gcd(a,b)*lcm(a,b) 

②gcd(a,b,c) = gcd(gcd(a,b),c) 

③lcm(a,b,c) = lcm(lcm(a,b),c) 

④gcd(lcm(a,b),c) = lcm(gcd(a,b),c)

-将问题转换成求gcd(a,b,c)的最大值

-枚举一个数i 并找在数组中存在的倍数ki ，将结果存入一个容器中

-从后往前遍历这个容器，找到的第一个大小大于3的，即是答案



## 核心代码

```
for(int i = 0;i<n;i++){
        cin>>h;
        ...
        m = max(m,h);
    }
    for(int i =1;i<=m;i++){
            for(int j = i;j<=m;j+=i){
                if(cnt[j]){
                    for(int k =0;k<cnt[j];k++){
                        v[i].push_back(j);    
                    }
                    
                }
            }
    }    
    for(int i = m;i>=1;i--){
        if(v[i].size()>=3){
            sort(v[i].begin(),v[i].end());
            for(int j = 0;j<3;j++) cout<<v[i][j]<<" ";
            break;
        }
    }
```



# 日志统计

## 模式：双指针+滑动窗口

## 关键点

-根据id对数据进行排序

-使用双指针去遍历数据

## 核心代码

```
unordered_map<int, vector<int>> logs; // 存储每个id对应的时间列表
    for (int i = 0; i < n; ++i) {
        int ts, id;
        cin >> ts >> id;
        logs[id].push_back(ts);
    }
    
    vector<int> res;
    
    // 遍历每个id的时间列表
    for (auto &pair : logs) {
        int id = pair.first;
        vector<int> &times = pair.second;
        sort(times.begin(), times.end());
        
        int left = 0, right = 0;
        int maxCount = 0;
        // 滑动窗口检查
        while (right < times.size()) {
            // 扩展右边界
            while (right < times.size() && times[right] - times[left] < d) {
                right++;
            }
            // 当前窗口内的数目是right - left
            if (right - left >= k) {
                res.push_back(id);
                break;
            }
            // 移动左边界
            left++;
        }
    }
    // 排序并输出结果
    sort(res.begin(), res.end());
    for (int id : res) {
        cout << id << endl;
    }
```



# 大臣的旅费

## 模式：数的直径+dfs+树形DP

## 关键点

-开数组的时候要稍微开大一点，因为是双向图，存取的要多一些

-使用前向星链表存储数据（大部分OJ题目中的：{起点，终点，权重}类型数据都是用前向星链表存储）

-因为是双向图，因此进行dfs遍历时要判断下一个节点是不是等于父节点，防止遍历回来

-求这一个图中两点最长的距离就是求树的直径。任选一点，求距离这点最远的点x，再求距离x最远的点y，x与y的距离即为树的直径。（dfs两次）

-在进行计算过程中如果可能爆int，那应该在计算过程中就进行数据类型转换，而不只是用longlong类型的变量存储结果。

## 核心代码

```
const int N = 1e6 +10; //因为是双向图，所以要存的节点数×2；
int head[N];int max_point,max_dis = 0;
struct Edge{
    int w,to,next;
}edges[N];

void add(int from,int to,int w){
    edges[++cnt].w = w;
    edges[cnt].to = to;
    edges[cnt].next = head[from];
    head[from] = cnt;
}

void dfs(int start,int father,int w){
    for(int i = head[start];i!=0;i = edges[i].next){
        int j = edges[i].to; //下一个节点
        int dis = edges[i].w; //边的权重，即距离
        if(j==father) continue; //父节点和下一个节点一样，说明在往回遍历了，需要停止;
        if(max_dis<w+dis){
            max_dis = w+dis; //更新最远距离
            max_point = j; //更新抵达的最远的点
        }
        dfs(j,start,w+dis);
    }
}
...
    for(int i = 0;i<n-1;i++){
        int p1,p2,dis;
        // scanf("%d%d%d",&p1,&p2,&dis);
        cin>>p1>>p2>>dis;
        add(p1,p2,dis);
        add(p2,p1,dis);
    }
    dfs(1,-1,0);
    dfs(max_point,-1,0);
    cout << max_dis*10 + (1ll+max_dis)*(max_dis)/2 << endl;
```



# 航班时间

## 模式：模拟+处理输入

## 关键点

-利用scanf的严格匹配来做到精准读取数值

-但要注意区分的一点是，scanf会读取缓冲区的内容，如果有的内容在上一次没被正确处理，那么可能被错误的读取，但本题不存在这种情况。

## 核心代码

```
while(n--){
        d = 0;
        scanf("%d:%d:%d %d:%d:%d (+%d)",&h1,&m1,&s1,&h2,&m2,&s2,&d);
        int time1 = d*24*3600 + h2*3600 + m2*60 + s2 - (h1*3600 + m1*60 + s1);
        d = 0;
        scanf("%d:%d:%d %d:%d:%d (+%d)",&h1,&m1,&s1,&h2,&m2,&s2,&d);
        int time2 = d*24*3600 + h2*3600 + m2*60 + s2 - (h1*3600 + m1*60 + s1);
        int diff = (time2 + time1) /2;
        printf("%02d:%02d:%02d\n",diff/3600,diff/60%60,diff%60);
    }
```









# 四平方和







# 带分数



# 飞行员兄弟



# 费解的开关



# 记笔记模板

{题目名}

模式（算法）：....（时间复杂度xxx）

关键点

-关键点1

-关键点2

变体（可选）

-若允许重复使用元素？ -> 修改指针移动逻辑

-若改为......

核心操作：

```
//some code
```

易错点：

相关题目：
